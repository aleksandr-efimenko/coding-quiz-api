{
  "title": "JavaScript Objects Quiz",
  "tags": [
    "objects",
    "javascript"
  ],
  "questions": [
    {
      "text": "#Singleton with Closure (Classic JS Pattern)",
      "options": [
        {
          "text": "ECMAScript 5 introduced javascript object accessors or computed properties through getters and setters",
          "is_correct": false
        },
        {
          "text": "In modern JavaScript applications, singletons are commonly implemented using ES6 modules for their built-in caching behavior, or closures for encapsulated state management",
          "is_correct": true
        },
        {
          "text": "WebWorkers don't have access to below javascript objects since they are defined in an external files\n\n    1",
          "is_correct": false
        },
        {
          "text": "All objects have prototypes except two exceptions:\n      *  **Object",
          "is_correct": false
        }
      ],
      "explanation": "```javascript\n        const Singleton = (function () {\n        let instance;\n\n        function createInstance() {\n          return { name: \"Sudheer\" };\n        }\n\n        return {\n          getInstance: function () {\n            if (!instance) {\n              instance = createInstance();\n            }\n            return instance;\n          }\n        };\n        })();\n\n        // Usage\n        const obj1 = Singleton.getInstance();\n        const obj2 = Singleton.getInstance();\n\n        console.log(obj1 === obj2); // true\n        ```\n         In modern JavaScript applications, singletons are commonly implemented using ES6 modules for their built-in caching behavior, or closures for encapsulated state management.\n\n2."
    },
    {
      "text": "What is a prototype chain",
      "options": [
        {
          "text": "Eventhough both variables `a` and `b` refer a number value, the first declaration is based on constructor function and the type of the variable is going to be `object` type",
          "is_correct": false
        },
        {
          "text": "Eventhough the above function returns the same result for the same arguments(input) that are passed in the function, the `console",
          "is_correct": false
        },
        {
          "text": "The prototype chain is a core concept in JavaScript’s inheritance model",
          "is_correct": true
        },
        {
          "text": "You can use the `String",
          "is_correct": false
        }
      ],
      "explanation": "The prototype chain is a core concept in JavaScript’s inheritance model. It allows objects to inherit properties and methods from other objects. When you try to access a property or method on an object, JavaScript first looks for it on that object itself. If it’s not found, the engine looks up the object's internal `[[Prototype]]` reference (accessible via `Object.getPrototypeOf(obj)` or the deprecated `__proto__` property) and continues searching up the chain until it finds the property or reaches the end (usually `null`).\n\n    For objects created via constructor functions, the prototype chain starts with the instance, then refers to the constructor’s `.prototype` object, and continues from there. For example:\n\n    ```javascript\n    function Person() {}\n    const person1 = new Person();\n\n    console.log(Object.getPrototypeOf(person1) === Person.prototype); // true\n    ```\n\n    This mechanism allows for property and method sharing among objects, enabling code reuse and a form of inheritance.\n\n    **Summary:**\n\n    *   The prototype chain enables inheritance in JavaScript.\n    *   If a property isn’t found on an object, JavaScript looks up its prototype chain.\n    *   The prototype of an object instance can be accessed with `Object.getPrototypeOf(obj)` or `__proto__`.\n    *   The prototype of a constructor function is available via `Constructor.prototype`.\n    *   The chain ends when the prototype is `null`.\n\n    The prototype chain among objects appears as below, \n    \n    ![Screenshot](images/prototype_chain.png)\n\n3."
    },
    {
      "text": "What is the Difference Between `call`, `apply`, and `bind`",
      "options": [
        {
          "text": "JavaScript is a loosely typed or a dynamic language because variables in JavaScript are not directly associated with any particular value type, and any variable can be assigned/reassigned with values of all types",
          "is_correct": false
        },
        {
          "text": "Heap(Or memory heap) is the memory location where objects are stored when we define variables",
          "is_correct": false
        },
        {
          "text": "In JavaScript, `call`, `apply`, and `bind` are methods that allow you to control the context (`this` value) in which a function is executed",
          "is_correct": true
        },
        {
          "text": "ES6 provides method definitions and property shorthands for objects",
          "is_correct": false
        }
      ],
      "explanation": "In JavaScript, `call`, `apply`, and `bind` are methods that allow you to control the context (`this` value) in which a function is executed. While their purposes are similar, they differ in how they handle arguments and when the function is invoked.\n\n  ---"
    },
    {
      "text": "Common Operations with JSON",
      "options": [
        {
          "text": "Both are totally unrelated programming languages and no relation between them",
          "is_correct": false
        },
        {
          "text": "According to ECMAScript specification 262 (9",
          "is_correct": false
        },
        {
          "text": "**Parsing**: Transforming a JSON-formatted string into a native JavaScript object",
          "is_correct": true
        },
        {
          "text": "Below are the list of placeholders available from console object,\n\n      1",
          "is_correct": false
        }
      ],
      "explanation": "1. **Parsing**: Transforming a JSON-formatted string into a native JavaScript object.\n      ```js\n      const obj = JSON.parse(jsonString);\n      ```\n      - Example:  \n        ```js\n        const jsonString = '{\"name\":\"John\",\"age\":30}';\n        const obj = JSON.parse(jsonString);  // { name: \"John\", age: 30 }\n        ```\n\n    2. **Stringification**: Converting a JavaScript object into a JSON-formatted string, commonly used for data transmission or storage.\n      ```js\n      const jsonString = JSON.stringify(object);\n      ```\n      - Example:  \n        ```js\n        const obj = { name: \"Jane\", age: 25 };\n        const jsonString = JSON.stringify(obj);  // '{\"name\":\"Jane\",\"age\":25}'\n        ```\n\n5."
    },
    {
      "text": "Strict Equality (`===`)",
      "options": [
        {
          "text": "Two strings are strictly equal if they have exactly the same sequence of characters and length",
          "is_correct": true
        },
        {
          "text": "The super keyword is used to call methods of a superclass",
          "is_correct": false
        },
        {
          "text": "A `WeakSet` is used to store a collection of weakly(weak references) held objects",
          "is_correct": false
        },
        {
          "text": "WebWorkers don't have access to below javascript objects since they are defined in an external files\n\n    1",
          "is_correct": false
        }
      ],
      "explanation": "- Two strings are strictly equal if they have exactly the same sequence of characters and length.\n    - Two numbers are strictly equal if they have the same numeric value.\n      - **Special cases:**\n        - `NaN === NaN` is `false`\n        - `+0 === -0` is `true`\n    - Two booleans are strictly equal if both are `true` or both are `false`.\n    - Two objects are strictly equal if they refer to the **same object** in memory.\n    - `null` and `undefined` are **not** strictly equal."
    },
    {
      "text": "What is the currying function",
      "options": [
        {
          "text": "An object initializer is an expression that describes the initialization of an Object",
          "is_correct": false
        },
        {
          "text": "Currying** is the process of transforming a function with **multiple arguments** into a sequence of **nested functions**, each accepting **only one argument** at a time",
          "is_correct": true
        },
        {
          "text": "Primitive Values like string,number and boolean don't have properties and methods but they are temporarily converted or coerced to an object(Wrapper object) when you try to perform actions on them",
          "is_correct": false
        },
        {
          "text": "Arrow functions do not have an `arguments, super, this, or new",
          "is_correct": false
        }
      ],
      "explanation": "**Currying** is the process of transforming a function with **multiple arguments** into a sequence of **nested functions**, each accepting **only one argument** at a time.\n\n    This concept is named after mathematician **Haskell Curry**, and is commonly used in functional programming to enhance modularity and reuse.\n\n    ## Before Currying (Normal n-ary Function)\n\n    ```javascript\n    const multiArgFunction = (a, b, c) => a + b + c;\n\n    console.log(multiArgFunction(1, 2, 3)); // Output: 6\n    ```\n    This is a standard function that takes three arguments at once.\n\n    ## After Currying (Unary Function Chain)\n    ```javascript\n    const curryUnaryFunction = (a) => (b) => (c) => a + b + c;\n\n    console.log(curryUnaryFunction(1));       // Returns: function (b) => ...\n    console.log(curryUnaryFunction(1)(2));    // Returns: function (c) => ...\n    console.log(curryUnaryFunction(1)(2)(3)); // Output: 6\n\n    ```\n    Each function in the chain accepts one argument and returns the next function, until all arguments are provided and the final result is computed.\n\n    ## Benefits of Currying\n      - Improves code reusability\n      → You can partially apply functions with known arguments.\n\n      - Enhances functional composition\n      → Easier to compose small, pure functions.\n\n      - Encourages clean, modular code\n      → You can split logic into smaller single-responsibility functions.\n\n16."
    },
    {
      "text": "What are classes in ES6",
      "options": [
        {
          "text": "By default, plain objects are not iterable",
          "is_correct": false
        },
        {
          "text": "In ES6, Javascript classes are primarily syntactic sugar over JavaScript’s existing prototype-based inheritance",
          "is_correct": true
        },
        {
          "text": "There are two possible solutions to add new properties to an object",
          "is_correct": false
        },
        {
          "text": "Below are the list of properties available on the `Intl` object,\n\n      1",
          "is_correct": false
        }
      ],
      "explanation": "In ES6, Javascript classes are primarily syntactic sugar over JavaScript’s existing prototype-based inheritance.\n    For example, the prototype based inheritance written in function expression as below,\n\n    ```javascript\n    function Bike(model, color) {\n      this.model = model;\n      this.color = color;\n    }\n\n    Bike.prototype.getDetails = function () {\n      return this.model + \" bike has\" + this.color + \" color\";\n    };\n    ```\n\n    Whereas ES6 classes can be defined as an alternative\n\n    ```javascript\n    class Bike {\n      constructor(color, model) {\n        this.color = color;\n        this.model = model;\n      }\n\n      getDetails() {\n        return this.model + \" bike has\" + this.color + \" color\";\n      }\n    }\n    ```\n\n28."
    },
    {
      "text": "What are modules",
      "options": [
        {
          "text": "JavaScript provided a trim method on string types to trim any whitespaces present at the beginning or ending of the string",
          "is_correct": false
        },
        {
          "text": "First, we should know about tail call before talking about \"Proper Tail Call\"",
          "is_correct": false
        },
        {
          "text": "Since `Set` object is a collection of unique values, it won't allow duplicate values in the collection",
          "is_correct": false
        },
        {
          "text": "Modules refer to small units of independent, reusable code and also act as the foundation of many JavaScript design patterns",
          "is_correct": true
        }
      ],
      "explanation": "Modules refer to small units of independent, reusable code and also act as the foundation of many JavaScript design patterns. Most of the JavaScript modules export an object literal, a function, or a constructor\n\n30."
    },
    {
      "text": "What is scope in javascript",
      "options": [
        {
          "text": "You can use innerWidth, innerHeight, clientWidth, clientHeight properties of windows, document element and document body objects to find the size of a window",
          "is_correct": false
        },
        {
          "text": "Sometimes you would like to have a destructured variable with a different name than the property name",
          "is_correct": false
        },
        {
          "text": "Scope is the accessibility of variables, functions, and objects in some particular part of your code during runtime",
          "is_correct": true
        },
        {
          "text": "A property descriptor is a record which has the following attributes\n\n      1",
          "is_correct": false
        }
      ],
      "explanation": "Scope is the accessibility of variables, functions, and objects in some particular part of your code during runtime. In other words, scope determines the visibility of variables and other resources in areas of your code.\n\n32."
    },
    {
      "text": "What is web storage",
      "options": [
        {
          "text": "Scope is the accessibility of variables, functions, and objects in some particular part of your code during runtime",
          "is_correct": false
        },
        {
          "text": "The value null represents the intentional absence of any object value",
          "is_correct": false
        },
        {
          "text": "history object contains the browser's history",
          "is_correct": false
        },
        {
          "text": "Web storage is an API that provides a mechanism by which browsers can store key/value pairs locally within the user's browser, in a much more intuitive fashion than using cookies",
          "is_correct": true
        }
      ],
      "explanation": "Web storage is an API that provides a mechanism by which browsers can store key/value pairs locally within the user's browser, in a much more intuitive fashion than using cookies. The web storage provides two mechanisms for storing data on the client.\n\n    1. **Local storage:** It stores data for current origin with no expiration date.\n    2. **Session storage:** It stores data for one session and the data is lost when the browser tab is closed.\n\n37."
    },
    {
      "text": "Why do you need a Cookie",
      "options": [
        {
          "text": "All objects have prototypes except two exceptions:\n      *  **Object",
          "is_correct": false
        },
        {
          "text": "Cookies are used to remember information about the user profile(such as username)",
          "is_correct": true
        },
        {
          "text": "A return statement in a generator function will make the generator finish",
          "is_correct": false
        },
        {
          "text": "Below are the list of properties available on the `Intl` object,\n\n      1",
          "is_correct": false
        }
      ],
      "explanation": "Cookies are used to remember information about the user profile(such as username). It basically involves two steps,\n\n    1. When a user visits a web page, the user profile can be stored in a cookie.\n    2. Next time the user visits the page, the cookie remembers the user profile.\n\n40."
    },
    {
      "text": "How do you access web storage",
      "options": [
        {
          "text": "The Window object implements the `WindowLocalStorage` and `WindowSessionStorage` objects which has `localStorage`(window",
          "is_correct": true
        },
        {
          "text": "The typeof operator on any primitive returns a string value",
          "is_correct": false
        },
        {
          "text": "Regular Expressions provide a group of patterns in order to match characters",
          "is_correct": false
        },
        {
          "text": "The main points in the above code snippets are,\n\n1",
          "is_correct": false
        }
      ],
      "explanation": "The Window object implements the `WindowLocalStorage` and `WindowSessionStorage` objects which has `localStorage`(window.localStorage) and `sessionStorage`(window.sessionStorage) properties respectively. These properties create an instance of the Storage object, through which data items can be set, retrieved and removed for a specific domain and storage type (session or local).\n    For example, you can read and write on local storage objects as below\n\n    ```javascript\n    localStorage.setItem(\"logo\", document.getElementById(\"logo\").value);\n    localStorage.getItem(\"logo\");\n    ```\n\n45."
    },
    {
      "text": "Why do you need web storage",
      "options": [
        {
          "text": "You can use the `super` keyword to call the constructor of a parent class",
          "is_correct": false
        },
        {
          "text": "There are 3 possible ways to check whether a string contains a substring or not,\n\n      1",
          "is_correct": false
        },
        {
          "text": "Web storage is more secure, and large amounts of data can be stored locally, without affecting website performance",
          "is_correct": true
        },
        {
          "text": "A property descriptor is a record which has the following attributes\n\n      1",
          "is_correct": false
        }
      ],
      "explanation": "Web storage is more secure, and large amounts of data can be stored locally, without affecting website performance. Also, the information is never transferred to the server. Hence this is a more recommended approach than Cookies.\n\n48."
    },
    {
      "text": "What are the restrictions of web workers on DOM",
      "options": [
        {
          "text": "Since JavaScript is a dynamic programming language, you can add or remove properties and methods from objects on the fly at runtime",
          "is_correct": false
        },
        {
          "text": "create()` method is used to create a new object with the specified prototype object and properties",
          "is_correct": false
        },
        {
          "text": "When you apply 'use strict'; syntax, some of the below cases will throw a SyntaxError before executing the script\n\n      1",
          "is_correct": false
        },
        {
          "text": "WebWorkers don't have access to below javascript objects since they are defined in an external files\n\n    1",
          "is_correct": true
        }
      ],
      "explanation": "WebWorkers don't have access to below javascript objects since they are defined in an external files\n\n    1. Window object\n    2. Document object\n    3. Parent object\n\n52."
    },
    {
      "text": "How do you receive server-sent event notifications",
      "options": [
        {
          "text": "The EventSource object is used to receive server-sent event notifications",
          "is_correct": true
        },
        {
          "text": "If you leave out the right-hand side assignment for the destructuring object, the function will look for at least one argument to be supplied when invoked",
          "is_correct": false
        },
        {
          "text": "Web storage is more secure, and large amounts of data can be stored locally, without affecting website performance",
          "is_correct": false
        },
        {
          "text": "Yes, JavaScript is a case sensitive language",
          "is_correct": false
        }
      ],
      "explanation": "The EventSource object is used to receive server-sent event notifications. For example, you can receive messages from server as below,\n\n    ```javascript\n    if (typeof EventSource !== \"undefined\") {\n      var source = new EventSource(\"sse_generator.js\");\n      source.onmessage = function (event) {\n        document.getElementById(\"output\").innerHTML += event.data + \"\";\n      };\n    }\n    ```\n\n60."
    },
    {
      "text": "Why do you need strict mode",
      "options": [
        {
          "text": "target` pseudo-property to detect whether a function was called as a constructor(using the new operator) or as a regular function call",
          "is_correct": false
        },
        {
          "text": "The custom bind function needs to be created on Function prototype inorder to use it as other builtin functions",
          "is_correct": false
        },
        {
          "text": "Eventhough the above function returns the same result for the same arguments(input) that are passed in the function, the `console",
          "is_correct": false
        },
        {
          "text": "Strict mode is useful to write \"secure\" JavaScript by notifying \"bad syntax\" into real errors",
          "is_correct": true
        }
      ],
      "explanation": "Strict mode is useful to write \"secure\" JavaScript by notifying \"bad syntax\" into real errors. For example, it eliminates accidentally creating a global variable by throwing an error and also throws an error for assignment to a non-writable property, a getter-only property, a non-existing property, a non-existing variable, or a non-existing object.\n\n69."
    },
    {
      "text": "What is null value",
      "options": [
        {
          "text": "The value null represents the intentional absence of any object value",
          "is_correct": true
        },
        {
          "text": "In the Object-oriented paradigm, an existing API contains certain elements that are not intended to be extended, modified, or re-used outside of their current context",
          "is_correct": false
        },
        {
          "text": "In ES6, Javascript classes are primarily syntactic sugar over JavaScript’s existing prototype-based inheritance",
          "is_correct": false
        },
        {
          "text": "Below are the list of properties available on the `Intl` object,\n\n      1",
          "is_correct": false
        }
      ],
      "explanation": "The value null represents the intentional absence of any object value. It is one of JavaScript's primitive values. The type of null value is object.\n    You can empty the variable by setting the value to null.\n\n    ```javascript\n    var user = null;\n    console.log(typeof user); //object\n    ```\n\n75."
    },
    {
      "text": "What is the difference between window and document",
      "options": [
        {
          "text": "A decorator is an expression that evaluates to a function and that takes the target, name, and decorator descriptor as arguments",
          "is_correct": false
        },
        {
          "text": "This is also known as Document Object Model (DOM) |\n    | By default window object is available implicitly in the page                  | You can access it via window",
          "is_correct": true
        },
        {
          "text": "You can use the `for-in` loop to loop through javascript object",
          "is_correct": false
        },
        {
          "text": "isFrozen()` method is used to determine if an object is frozen or not",
          "is_correct": false
        }
      ],
      "explanation": "Below are the main differences between window and document,\n\n    | Window                                                                        | Document                                                                                       |\n    | ----------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------- |\n    | It is the root level element in any web page                                  | It is the direct child of the window object. This is also known as Document Object Model (DOM) |\n    | By default window object is available implicitly in the page                  | You can access it via window.document or document.                                             |\n    | It has methods like alert(), confirm() and properties like document, location | It provides methods like getElementById, getElementsByTagName, createElement etc               |\n\n78."
    },
    {
      "text": "How do you access history in javascript",
      "options": [
        {
          "text": "The EvalError object indicates an error regarding the global `eval()` function",
          "is_correct": false
        },
        {
          "text": "history object contains the browser's history",
          "is_correct": true
        },
        {
          "text": "isExtensible()` method is used to determine if an object is extendable or not",
          "is_correct": false
        },
        {
          "text": "In order to be consistent with functions like `String",
          "is_correct": false
        }
      ],
      "explanation": "The window.history object contains the browser's history. You can load previous and next URLs in the history using back() and next() methods.\n\n    ```javascript\n    function goBack() {\n      window.history.back();\n    }\n    function goForward() {\n      window.history.forward();\n    }\n    ```\n\n    **Note:** You can also access history without window prefix.\n\n79."
    },
    {
      "text": "What is an event flow",
      "options": [
        {
          "text": "Event flow refers to the order in which events are handled in the browser when a user interacts with elements on a webpage like clicking, typing, hovering, etc",
          "is_correct": true
        },
        {
          "text": "Yes, you can apply CSS styles to console messages similar to html text on the web page",
          "is_correct": false
        },
        {
          "text": "There are 3 possible ways for accessing the property of an object",
          "is_correct": false
        },
        {
          "text": "The EvalError object indicates an error regarding the global `eval()` function",
          "is_correct": false
        }
      ],
      "explanation": "Event flow refers to the order in which events are handled in the browser when a user interacts with elements on a webpage like clicking, typing, hovering, etc.\n\n    When you click an element that is nested in various other elements, before your click actually reaches its destination, or target element, it must trigger the click event for each of its parent elements first, starting at the top with the global window object.\n\n    Hence, there are three phases in JavaScript’s event flow:\n\n    1. Event Capturing(Top to Bottom): The event starts from the window/document and moves down the DOM tree toward the target element.\n    2. Target phase: The event reaches the target element — the element that was actually interacted with.\n    3. Event Bubbling(Bottom to Top): The event then bubbles back up from the target element to the root.\n\n87."
    },
    {
      "text": "What is event capturing",
      "options": [
        {
          "text": "Event capturing is a phase of event propagation in which an event is first intercepted by the outermost ancestor element, then travels downward through the DOM hierarchy until it reaches the target (innermost) element",
          "is_correct": true
        },
        {
          "text": "You can mark an object non-extensible in 3 ways,\n\n      1",
          "is_correct": false
        },
        {
          "text": "You can use the `` tag to detect javascript disabled or not",
          "is_correct": false
        },
        {
          "text": "Below are the list of properties available on the `Intl` object,\n\n      1",
          "is_correct": false
        }
      ],
      "explanation": "Event capturing is a phase of event propagation in which an event is first intercepted by the outermost ancestor element, then travels downward through the DOM hierarchy until it reaches the target (innermost) element.\n\n    To handle events during the capturing phase, you need to pass `true` as the third argument to the `addEventListener` method.\n\n     ```javascript\n      \n        Hello\n\n        const parent = document.querySelector(\"div\");\n        const child = document.querySelector(\".child\");\n\n        // Capturing phase: parent listener (runs first)\n        parent.addEventListener(\"click\", function () {\n          console.log(\"Parent (capturing)\");\n        }, true); // `true` enables capturing\n\n        // Bubbling phase: child listener (runs after)\n        child.addEventListener(\"click\", function () {\n          console.log(\"Child (bubbling)\");\n        });\n      \n      // Parent (capturing)\n      // Child (bubbling)\n     ```\n\n88."
    },
    {
      "text": "What is event bubbling",
      "options": [
        {
          "text": "WebWorkers don't have access to below javascript objects since they are defined in an external files\n\n    1",
          "is_correct": false
        },
        {
          "text": "Event bubbling is a type of event propagation in which an event first triggers on the innermost target element (the one the user interacted with), and then bubbles up through its ancestors in the DOM hierarchy — eventually reaching the outermost elements, like the document or window",
          "is_correct": true
        },
        {
          "text": "is()` method determines whether two values are the same value",
          "is_correct": false
        },
        {
          "text": "Yes, JavaScript is a case sensitive language",
          "is_correct": false
        }
      ],
      "explanation": "Event bubbling is a type of event propagation in which an event first triggers on the innermost target element (the one the user interacted with), and then bubbles up through its ancestors in the DOM hierarchy — eventually reaching the outermost elements, like the document or window.\n\n    By default, event listeners in JavaScript are triggered during the bubbling phase, unless specified otherwise.\n\n    ```javascript\n    \n      Hello\n\n      const parent = document.querySelector(\"div\");\n      const child = document.querySelector(\".child\");\n\n      // Bubbling phase (default)\n      parent.addEventListener(\"click\", function () {\n        console.log(\"Parent\");\n      });\n\n      child.addEventListener(\"click\", function () {\n        console.log(\"Child\");\n      });\n    \n    //Child\n    //Parent\n    ```\n\n    Here, at first, the event triggers on the child button. Thereafter it bubbles up and triggers the parent div's event handler.\n\n89."
    },
    {
      "text": "How do you find operating system details",
      "options": [
        {
          "text": "When you apply 'use strict'; syntax, some of the below cases will throw a SyntaxError before executing the script\n\n      1",
          "is_correct": false
        },
        {
          "text": "You can use the `for-in` loop to loop through javascript object",
          "is_correct": false
        },
        {
          "text": "navigator object contains information about the visitor's browser OS details",
          "is_correct": true
        },
        {
          "text": "You can use the `String",
          "is_correct": false
        }
      ],
      "explanation": "The window.navigator object contains information about the visitor's browser OS details. Some of the OS properties are available under platform property,\n\n    ```javascript\n    console.log(navigator.platform);\n    ```\n\n91."
    },
    {
      "text": "What is the difference between native, host and user objects",
      "options": [
        {
          "text": "Below are the list of methods available on `WeakSet`,\n\n      1",
          "is_correct": false
        },
        {
          "text": "`Native objects` are objects that are part of the JavaScript language defined by the ECMAScript specification",
          "is_correct": true
        },
        {
          "text": "JavaScript does not have built-in support for mixins as a formal language feature",
          "is_correct": false
        },
        {
          "text": "All objects have prototypes except two exceptions:\n      *  **Object",
          "is_correct": false
        }
      ],
      "explanation": "`Native objects` are objects that are part of the JavaScript language defined by the ECMAScript specification. For example, String, Math, RegExp, Object, Function etc core objects defined in the ECMAScript spec.\n    `Host objects` are objects provided by the browser or runtime environment (Node).\n\n    For example, window, XmlHttpRequest, DOM nodes etc are considered as host objects.\n    `User objects` are objects defined in the javascript code. For example, User objects created for profile information.\n\n93."
    },
    {
      "text": "What is same-origin policy",
      "options": [
        {
          "text": "Since `Set` object is a collection of unique values, it won't allow duplicate values in the collection",
          "is_correct": false
        },
        {
          "text": "The EvalError object indicates an error regarding the global `eval()` function",
          "is_correct": false
        },
        {
          "text": "Heap(Or memory heap) is the memory location where objects are stored when we define variables",
          "is_correct": false
        },
        {
          "text": "The same-origin policy is a policy that prevents JavaScript from making requests across domain boundaries",
          "is_correct": true
        }
      ],
      "explanation": "The same-origin policy is a policy that prevents JavaScript from making requests across domain boundaries. An origin is defined as a combination of URI scheme, hostname, and port number. If you enable this policy then it prevents a malicious script on one page from obtaining access to sensitive data on another web page using Document Object Model(DOM).\n\n97."
    },
    {
      "text": "Is JavaScript a case-sensitive language",
      "options": [
        {
          "text": "Yes, JavaScript is a case sensitive language",
          "is_correct": true
        },
        {
          "text": "dir()` is used to display an interactive list of the properties of the specified JavaScript object as JSON",
          "is_correct": false
        },
        {
          "text": "V8 engine uses the below optimization techniques",
          "is_correct": false
        },
        {
          "text": "The type of operator on new Number always returns object",
          "is_correct": false
        }
      ],
      "explanation": "Yes, JavaScript is a case sensitive language. The language keywords, variables, function & object names, and any other identifiers must always be typed with a consistent capitalization of letters.\n\n100."
    },
    {
      "text": "Is there any relation between Java and JavaScript",
      "options": [
        {
          "text": "The `new URL()` object accepts the url string and `searchParams` property of this object can be used to access the get parameters",
          "is_correct": false
        },
        {
          "text": "No, you cannot use the reserved words as variables, labels, object or function names",
          "is_correct": false
        },
        {
          "text": "In ES6, Javascript classes are primarily syntactic sugar over JavaScript’s existing prototype-based inheritance",
          "is_correct": false
        },
        {
          "text": "No, they are entirely two different programming languages and have nothing to do with each other",
          "is_correct": true
        }
      ],
      "explanation": "No, they are entirely two different programming languages and have nothing to do with each other. But both of them are Object Oriented Programming languages and like many other languages, they follow similar syntax for basic features(if, else, for, switch, break, continue etc).\n\n101."
    },
    {
      "text": "Who created javascript",
      "options": [
        {
          "text": "JavaScript was created by Brendan Eich in 1995 during his time at Netscape Communications",
          "is_correct": true
        },
        {
          "text": "Object literals make it easy to quickly create objects with properties inside the curly braces",
          "is_correct": false
        },
        {
          "text": "The `this` keyword in JavaScript refers to **the object that is executing the current function**",
          "is_correct": false
        },
        {
          "text": "When sending data to a web server, the data has to be in a string format",
          "is_correct": false
        }
      ],
      "explanation": "JavaScript was created by Brendan Eich in 1995 during his time at Netscape Communications. Initially it was developed under the name `Mocha`, but later the language was officially called `LiveScript` when it first shipped in beta releases of Netscape.\n\n103."
    },
    {
      "text": "What is BOM",
      "options": [
        {
          "text": "JavaScript is a multi-paradigm language, supporting imperative/procedural programming, Object-Oriented Programming and functional programming",
          "is_correct": false
        },
        {
          "text": "Web storage is an API that provides a mechanism by which browsers can store key/value pairs locally within the user's browser, in a much more intuitive fashion than using cookies",
          "is_correct": false
        },
        {
          "text": "The Browser Object Model (BOM) allows JavaScript to \"talk to\" the browser",
          "is_correct": true
        },
        {
          "text": "Due to hositing feature, the variables declared with `var` will have `undefined` value in the creation phase so the outer variable `currentCity` will get same `undefined` value",
          "is_correct": false
        }
      ],
      "explanation": "The Browser Object Model (BOM) allows JavaScript to \"talk to\" the browser. It consists of the objects navigator, history, screen, location and document which are children of the window. The Browser Object Model is not standardized and can change based on different browsers.\n\n      ![Screenshot](images/bom.png)\n\n107."
    },
    {
      "text": "What is JSON",
      "options": [
        {
          "text": "`Symbol` is a just a standard function and not an object constructor(unlike other primitives new Boolean, new String and new Number)",
          "is_correct": false
        },
        {
          "text": "JavaScript provided a trim method on string types to trim any whitespaces present at the beginning or ending of the string",
          "is_correct": false
        },
        {
          "text": "JSON (JavaScript Object Notation) is a lightweight format that is used for data interchanging",
          "is_correct": true
        },
        {
          "text": "A _repaint_ occurs when changes are made which affect the visibility of an element, but not its layout",
          "is_correct": false
        }
      ],
      "explanation": "JSON (JavaScript Object Notation) is a lightweight format that is used for data interchanging. It is based on a subset of JavaScript language in the way objects are built in JavaScript.\n\n113."
    },
    {
      "text": "What is the purpose JSON stringify",
      "options": [
        {
          "text": "Unlike function declarations, class declarations are not hoisted",
          "is_correct": false
        },
        {
          "text": "Arrow functions do not have an `arguments, super, this, or new",
          "is_correct": false
        },
        {
          "text": "Strict mode is useful to write \"secure\" JavaScript by notifying \"bad syntax\" into real errors",
          "is_correct": false
        },
        {
          "text": "When sending data to a web server, the data has to be in a string format",
          "is_correct": true
        }
      ],
      "explanation": "When sending data to a web server, the data has to be in a string format. You can achieve this by converting JSON object into a string using stringify() method.\n\n      ```javascript\n      var userJSON = { name: \"John\", age: 31 };\n      var userString = JSON.stringify(userJSON);\n      console.log(userString); //\"{\"name\":\"John\",\"age\":31}\"\n      ```\n\n115."
    },
    {
      "text": "How do you parse JSON string",
      "options": [
        {
          "text": "The `uneval` function returns the source of a given object; whereas the `eval` function does the opposite, by evaluating that source code in a different memory area",
          "is_correct": false
        },
        {
          "text": "When receiving the data from a web server, the data is always in a string format",
          "is_correct": true
        },
        {
          "text": "Browsers provide an XMLHttpRequest object which can be used to make synchronous HTTP requests from JavaScript",
          "is_correct": false
        },
        {
          "text": "There are different solutions based on ECMAScript versions\n\n      1",
          "is_correct": false
        }
      ],
      "explanation": "When receiving the data from a web server, the data is always in a string format. But you can convert this string value to a javascript object using parse() method.\n\n      ```javascript\n      var userString = '{\"name\":\"John\",\"age\":31}';\n      var userJSON = JSON.parse(userString);\n      console.log(userJSON); // {name: \"John\", age: 31}\n      ```\n\n116."
    },
    {
      "text": "How do you redirect new page in javascript",
      "options": [
        {
          "text": "There are two possible solutions to add new properties to an object",
          "is_correct": false
        },
        {
          "text": "If you want to access any element in an HTML page, you need to start with accessing the document object",
          "is_correct": false
        },
        {
          "text": "In vanilla javascript, you can redirect to a new page using the `location` property of window object",
          "is_correct": true
        },
        {
          "text": "`Symbol` is a just a standard function and not an object constructor(unlike other primitives new Boolean, new String and new Number)",
          "is_correct": false
        }
      ],
      "explanation": "In vanilla javascript, you can redirect to a new page using the `location` property of window object. The syntax would be as follows,\n\n      ```javascript\n      function redirect() {\n        window.location.href = \"newPage.html\";\n      }\n      ```\n\n121."
    },
    {
      "text": "How do you check whether a string contains a substring",
      "options": [
        {
          "text": "The requestAnimationFrame() method in JavaScript is used to schedule a function to be called before the next repaint of the browser window, allowing you to create smooth, efficient animations",
          "is_correct": false
        },
        {
          "text": "In ES5, it will throw a TypeError exception if the obj parameter isn't an object",
          "is_correct": false
        },
        {
          "text": "You can programmatically get the image and check the dimensions(width and height) using Javascript",
          "is_correct": false
        },
        {
          "text": "There are 3 possible ways to check whether a string contains a substring or not,\n\n      1",
          "is_correct": true
        }
      ],
      "explanation": "There are 3 possible ways to check whether a string contains a substring or not,\n\n      1. **Using includes:** ES6 provided `String.prototype.includes` method to test a string contains a substring\n\n      ```javascript\n      var mainString = \"hello\",\n        subString = \"hell\";\n      mainString.includes(subString);\n      ```\n\n      2. **Using indexOf:** In an ES5 or older environment, you can use `String.prototype.indexOf` which returns the index of a substring. If the index value is not equal to -1 then it means the substring exists in the main string.\n\n      ```javascript\n      var mainString = \"hello\",\n        subString = \"hell\";\n      mainString.indexOf(subString) !== -1;\n      ```\n\n      3. **Using RegEx:** The advanced solution is using Regular expression's test method(`RegExp.test`), which allows for testing for against regular expressions\n\n      ```javascript\n      var mainString = \"hello\",\n        regex = /hell/;\n      regex.test(mainString);\n      ```\n\n122."
    },
    {
      "text": "What are the various url properties of location object",
      "options": [
        {
          "text": "IIFE(Immediately Invoked Function Expression) is just like any other function expression which won't be hoisted",
          "is_correct": false
        },
        {
          "text": "The `new URL()` object accepts the url string and `searchParams` property of this object can be used to access the get parameters",
          "is_correct": false
        },
        {
          "text": "Even though we used constant variables, the content of it is an object and the object's contents (e",
          "is_correct": false
        },
        {
          "text": "The below `Location` object properties can be used to access URL components of the page,\n\n      1",
          "is_correct": true
        }
      ],
      "explanation": "The below `Location` object properties can be used to access URL components of the page,\n\n      1. href - The entire URL\n      2. protocol - The protocol of the URL\n      3. host - The hostname and port of the URL\n      4. hostname - The hostname of the URL\n      5. port - The port number in the URL\n      6. pathname - The path name of the URL\n      7. search - The query portion of the URL\n      8. hash - The anchor portion of the URL\n\n125."
    },
    {
      "text": "How do you check if a key exists in an object",
      "options": [
        {
          "text": "The main difference between function declarations and class declarations is `hoisting`",
          "is_correct": false
        },
        {
          "text": "Below are the list of properties available on the `Intl` object,\n\n      1",
          "is_correct": false
        },
        {
          "text": "You can use the `String",
          "is_correct": false
        },
        {
          "text": "You can check whether a key exists in an object or not using three approaches,\n\n      1",
          "is_correct": true
        }
      ],
      "explanation": "You can check whether a key exists in an object or not using three approaches,\n\n      1. **Using in operator:** You can use the in operator whether a key exists in an object or not\n\n         ```javascript\n         \"key\" in obj;\n         ```\n\n         and If you want to check if a key doesn't exist, remember to use parenthesis,\n\n         ```javascript\n         !(\"key\" in obj);\n         ```\n\n      2. **Using hasOwnProperty method:** You can use `hasOwnProperty` to particularly test for properties of the object instance (and not inherited properties)\n\n         ```javascript\n         obj.hasOwnProperty(\"key\"); // true\n         ```\n\n      3. **Using undefined comparison:** If you access a non-existing property from an object, the result is undefined. Let’s compare the properties against undefined to determine the existence of the property.\n\n         ```javascript\n         const user = {\n           name: \"John\",\n         };\n\n         console.log(user.name !== undefined); // true\n         console.log(user.nickName !== undefined); // false\n         ```\n\n127."
    },
    {
      "text": "How do you loop through or enumerate javascript object",
      "options": [
        {
          "text": "You can use the `for-in` loop to loop through javascript object",
          "is_correct": true
        },
        {
          "text": "V8 engine uses the below optimization techniques",
          "is_correct": false
        },
        {
          "text": "A _repaint_ occurs when changes are made which affect the visibility of an element, but not its layout",
          "is_correct": false
        },
        {
          "text": "`Native objects` are objects that are part of the JavaScript language defined by the ECMAScript specification",
          "is_correct": false
        }
      ],
      "explanation": "You can use the `for-in` loop to loop through javascript object. You can also make sure that the key you get is an actual property of an object, and doesn't come from the prototype using `hasOwnProperty` method.\n\n      ```javascript\n      var object = {\n        k1: \"value1\",\n        k2: \"value2\",\n        k3: \"value3\",\n      };\n\n      for (var key in object) {\n        if (object.hasOwnProperty(key)) {\n          console.log(key + \" -> \" + object[key]); // k1 -> value1 ...\n        }\n      }\n      ```\n\n128."
    },
    {
      "text": "How do you test for an empty object",
      "options": [
        {
          "text": "There are different solutions based on ECMAScript versions\n\n      1",
          "is_correct": true
        },
        {
          "text": "Eventhough both variables `a` and `b` refer a number value, the first declaration is based on constructor function and the type of the variable is going to be `object` type",
          "is_correct": false
        },
        {
          "text": "The main points in the above code snippets are,\n\n1",
          "is_correct": false
        },
        {
          "text": "Cookies are used to remember information about the user profile(such as username)",
          "is_correct": false
        }
      ],
      "explanation": "There are different solutions based on ECMAScript versions\n\n      1. **Using Object entries(ECMA 7+):** You can use object entries length along with constructor type.\n\n      ```javascript\n      Object.entries(obj).length === 0 && obj.constructor === Object; // Since date object length is 0, you need to check constructor check as well\n      ```\n\n      2. **Using Object keys(ECMA 5+):** You can use object keys length along with constructor type.\n\n      ```javascript\n      Object.keys(obj).length === 0 && obj.constructor === Object; // Since date object length is 0, you need to check constructor check as well\n      ```\n\n      3. **Using for-in with hasOwnProperty(Pre-ECMA 5):** You can use a for-in loop along with hasOwnProperty.\n\n      ```javascript\n      function isEmpty(obj) {\n        for (var prop in obj) {\n          if (obj.hasOwnProperty(prop)) {\n            return false;\n          }\n        }\n\n        return JSON.stringify(obj) === JSON.stringify({});\n      }\n      ```\n\n129."
    },
    {
      "text": "How do you display the current date in javascript",
      "options": [
        {
          "text": "You can use the `Intl",
          "is_correct": false
        },
        {
          "text": "There are two ways to copy an object,\n\n      **Shallow Copy:**\n      Shallow copy is a bitwise copy of an object",
          "is_correct": false
        },
        {
          "text": "You can create both link and script elements in the DOM and append them as child to head tag",
          "is_correct": false
        },
        {
          "text": "You can use `new Date()` to generate a new Date object containing the current date and time",
          "is_correct": true
        }
      ],
      "explanation": "You can use `new Date()` to generate a new Date object containing the current date and time. For example, let's display the current date in mm/dd/yyyy\n\n      ```javascript\n      var today = new Date();\n      var dd = String(today.getDate()).padStart(2, \"0\");\n      var mm = String(today.getMonth() + 1).padStart(2, \"0\"); //January is 0!\n      var yyyy = today.getFullYear();\n\n      today = mm + \"/\" + dd + \"/\" + yyyy;\n      document.write(today);\n      ```\n\n133."
    },
    {
      "text": "How do you compare two date objects",
      "options": [
        {
          "text": "Regular Expressions provide a group of patterns in order to match characters",
          "is_correct": false
        },
        {
          "text": "You need to use date",
          "is_correct": true
        },
        {
          "text": "According to ECMAScript specification 262 (9",
          "is_correct": false
        },
        {
          "text": "A return statement in a generator function will make the generator finish",
          "is_correct": false
        }
      ],
      "explanation": "You need to use date.getTime() method in order to compare unix timestamp values\n\n      ```javascript\n      var d1 = new Date();\n      var d2 = new Date(d1);\n      console.log(d1.getTime() === d2.getTime()); //True\n      console.log(d1 === d2); // False\n      ```\n\n134."
    },
    {
      "text": "How do you check if a string starts with another string",
      "options": [
        {
          "text": "The same-origin policy is a policy that prevents JavaScript from making requests across domain boundaries",
          "is_correct": false
        },
        {
          "text": "ECMAScript 5 introduced javascript object accessors or computed properties through getters and setters",
          "is_correct": false
        },
        {
          "text": "JavaScript does not have built-in support for mixins as a formal language feature",
          "is_correct": false
        },
        {
          "text": "You can use ECMAScript 6's `String",
          "is_correct": true
        }
      ],
      "explanation": "You can use ECMAScript 6's `String.prototype.startsWith()` method to check if a string starts with another string or not. But it is not yet supported in all browsers. Let's see an example to see this usage,\n\n      ```javascript\n      \"Good morning\".startsWith(\"Good\"); // true\n      \"Good morning\".startsWith(\"morning\"); // false\n      ```\n\n135."
    },
    {
      "text": "How do you trim a string in javascript",
      "options": [
        {
          "text": "The typeof operator on any primitive returns a string value",
          "is_correct": false
        },
        {
          "text": "JavaScript provided a trim method on string types to trim any whitespaces present at the beginning or ending of the string",
          "is_correct": true
        },
        {
          "text": "Even though we used constant variables, the content of it is an object and the object's contents (e",
          "is_correct": false
        },
        {
          "text": "If you leave out the right-hand side assignment for the destructuring object, the function will look for at least one argument to be supplied when invoked",
          "is_correct": false
        }
      ],
      "explanation": "JavaScript provided a trim method on string types to trim any whitespaces present at the beginning or ending of the string.\n\n      ```javascript\n      \"  Hello World   \".trim(); //Hello World\n      ```\n\n      If your browser(<IE9) doesn't support this method then you can use below polyfill.\n\n      ```javascript\n      if (!String.prototype.trim) {\n        (function () {\n          // Make sure we trim BOM and NBSP\n          var rtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n          String.prototype.trim = function () {\n            return this.replace(rtrim, \"\");\n          };\n        })();\n      }\n      ```\n\n136."
    },
    {
      "text": "How do you add a key value pair in javascript",
      "options": [
        {
          "text": "There are two possible solutions to add new properties to an object",
          "is_correct": true
        },
        {
          "text": "The javascript parser will automatically add a semicolon while parsing the source code",
          "is_correct": false
        },
        {
          "text": "Below are the list of placeholders available from console object,\n\n      1",
          "is_correct": false
        },
        {
          "text": "isExtensible()` method is used to determine if an object is extendable or not",
          "is_correct": false
        }
      ],
      "explanation": "There are two possible solutions to add new properties to an object.\n\n      Let's take a simple object to explain these solutions.\n\n      ```javascript\n      var object = {\n        key1: value1,\n        key2: value2,\n      };\n      ```\n\n      1. **Using dot notation:** This solution is useful when you know the name of the property\n\n      ```javascript\n      object.key3 = \"value3\";\n      ```\n\n      2. **Using square bracket notation:** This solution is useful when the name of the property is dynamically determined or the key's name is non-JS like \"user-name\"\n\n      ```javascript\n      obj[\"key3\"] = \"value3\";\n      ```\n\n137."
    },
    {
      "text": "Can we define properties for functions",
      "options": [
        {
          "text": "Yes, we can define properties for functions because functions are also objects",
          "is_correct": true
        },
        {
          "text": "Event bubbling is a type of event propagation in which an event first triggers on the innermost target element (the one the user interacted with), and then bubbles up through its ancestors in the DOM hierarchy — eventually reaching the outermost elements, like the document or window",
          "is_correct": false
        },
        {
          "text": "No, you cannot use the reserved words as variables, labels, object or function names",
          "is_correct": false
        },
        {
          "text": "Both are totally unrelated programming languages and no relation between them",
          "is_correct": false
        }
      ],
      "explanation": "Yes, we can define properties for functions because functions are also objects.\n\n      ```javascript\n      fn = function (x) {\n        //Function code goes here\n      };\n\n      fn.name = \"John\";\n\n      fn.profile = function (y) {\n        //Profile code goes here\n      };\n      ```\n\n142."
    },
    {
      "text": "What are regular expression patterns",
      "options": [
        {
          "text": "Regular Expressions provide a group of patterns in order to match characters",
          "is_correct": true
        },
        {
          "text": "The function's object has a **length** property which tells you how many formal parameters expected by a function",
          "is_correct": false
        },
        {
          "text": "The EventSource object is used to receive server-sent event notifications",
          "is_correct": false
        },
        {
          "text": "Browsers provide an XMLHttpRequest object which can be used to make synchronous HTTP requests from JavaScript",
          "is_correct": false
        }
      ],
      "explanation": "Regular Expressions provide a group of patterns in order to match characters. Basically they are categorized into 3 types,\n\n      1. **Brackets:** These are used to find a range of characters.\n         For example, below are some use cases,\n         1. [abc]: Used to find any of the characters between the brackets(a,b,c)\n         2. [0-9]: Used to find any of the digits between the brackets\n         3. (a|b): Used to find any of the alternatives separated with |\n      2. **Metacharacters:** These are characters with a special meaning.\n         For example, below are some use cases,\n         1. \\\\d: Used to find a digit\n         2. \\\\s: Used to find a whitespace character\n         3. \\\\b: Used to find a match at the beginning or ending of a word\n      3. **Quantifiers:** These are useful to define quantities.\n         For example, below are some use cases,\n         1. n+: Used to find matches for any string that contains at least one n\n         2. n\\*: Used to find matches for any string that contains zero or more occurrences of n\n         3. n?: Used to find matches for any string that contains zero or one occurrences of n\n\n159."
    },
    {
      "text": "What is a RegExp object",
      "options": [
        {
          "text": "preventExtensions()` method is used to prevent new properties from ever being added to an object",
          "is_correct": false
        },
        {
          "text": "You can perform HTML form validation automatically without using javascript",
          "is_correct": false
        },
        {
          "text": "RegExp object is a regular expression object with predefined properties and methods",
          "is_correct": true
        },
        {
          "text": "The constructor method is a special method for creating and initializing an object created within a class",
          "is_correct": false
        }
      ],
      "explanation": "RegExp object is a regular expression object with predefined properties and methods. Let's see the simple usage of RegExp object,\n\n      ```javascript\n      var regexp = new RegExp(\"\\\\w+\");\n      console.log(regexp);\n      // expected output: /\\w+/\n      ```\n\n160."
    },
    {
      "text": "How do you change the style of a HTML element",
      "options": [
        {
          "text": "You can change inline style or classname of a HTML element using javascript DOM-manipulation\n\n      1",
          "is_correct": true
        },
        {
          "text": "Using constructors, `new",
          "is_correct": false
        },
        {
          "text": "There are 3 possible ways for accessing the property of an object",
          "is_correct": false
        },
        {
          "text": "In modern JavaScript applications, singletons are commonly implemented using ES6 modules for their built-in caching behavior, or closures for encapsulated state management",
          "is_correct": false
        }
      ],
      "explanation": "You can change inline style or classname of a HTML element using javascript DOM-manipulation\n\n      1. **Using style property:** You can modify inline style using style property\n\n      ```javascript\n      document.getElementById(\"title\").style.fontSize = \"30px\";\n      ```\n\n      2. **Using ClassName property:** It is easy to modify element class using className property\n\n      ```javascript\n      document.getElementById(\"title\").className = \"custom-title\";\n      ```\n\n163."
    },
    {
      "text": "Can I use reserved words as identifiers",
      "options": [
        {
          "text": "No, you cannot use the reserved words as variables, labels, object or function names",
          "is_correct": true
        },
        {
          "text": "A property descriptor is a record which has the following attributes\n\n      1",
          "is_correct": false
        },
        {
          "text": "The main difference between function declarations and class declarations is `hoisting`",
          "is_correct": false
        },
        {
          "text": "Event bubbling is a type of event propagation in which an event first triggers on the innermost target element (the one the user interacted with), and then bubbles up through its ancestors in the DOM hierarchy — eventually reaching the outermost elements, like the document or window",
          "is_correct": false
        }
      ],
      "explanation": "No, you cannot use the reserved words as variables, labels, object or function names. Let's see one simple example,\n\n      ```javascript\n      var else = \"hello\"; // Uncaught SyntaxError: Unexpected token else\n      ```\n\n167."
    },
    {
      "text": "How do you get the image width and height using JS",
      "options": [
        {
          "text": "isExtensible()` method is used to determine if an object is extendable or not",
          "is_correct": false
        },
        {
          "text": "Below are the some of main applications of `Object",
          "is_correct": false
        },
        {
          "text": "According to MDN official docs, the optional chaining operator (?",
          "is_correct": false
        },
        {
          "text": "You can programmatically get the image and check the dimensions(width and height) using Javascript",
          "is_correct": true
        }
      ],
      "explanation": "You can programmatically get the image and check the dimensions(width and height) using Javascript.\n\n      ```javascript\n      var img = new Image();\n      img.onload = function () {\n        console.log(this.width + \"x\" + this.height);\n      };\n      img.src = \"http://www.google.com/intl/en_ALL/images/logo.gif\";\n      ```\n\n170."
    },
    {
      "text": "How do you make synchronous HTTP request",
      "options": [
        {
          "text": "Browsers provide an XMLHttpRequest object which can be used to make synchronous HTTP requests from JavaScript",
          "is_correct": true
        },
        {
          "text": "Due to hositing feature, the variables declared with `var` will have `undefined` value in the creation phase so the outer variable `currentCity` will get same `undefined` value",
          "is_correct": false
        },
        {
          "text": "It is recommended to use semicolons after every statement in JavaScript",
          "is_correct": false
        },
        {
          "text": "Below are the some of main applications of `Object",
          "is_correct": false
        }
      ],
      "explanation": "Browsers provide an XMLHttpRequest object which can be used to make synchronous HTTP requests from JavaScript.\n\n      ```javascript\n      function httpGet(theUrl) {\n        var xmlHttpReq = new XMLHttpRequest();\n        xmlHttpReq.open(\"GET\", theUrl, false); // false for synchronous request\n        xmlHttpReq.send(null);\n        return xmlHttpReq.responseText;\n      }\n      ```\n\n171."
    },
    {
      "text": "What are the properties used to get size of window",
      "options": [
        {
          "text": "You can use the `getTimezoneOffset` method of the date object",
          "is_correct": false
        },
        {
          "text": "All objects have prototypes except two exceptions:\n      *  **Object",
          "is_correct": false
        },
        {
          "text": "The same-origin policy is a policy that prevents JavaScript from making requests across domain boundaries",
          "is_correct": false
        },
        {
          "text": "You can use innerWidth, innerHeight, clientWidth, clientHeight properties of windows, document element and document body objects to find the size of a window",
          "is_correct": true
        }
      ],
      "explanation": "You can use innerWidth, innerHeight, clientWidth, clientHeight properties of windows, document element and document body objects to find the size of a window. Let's use them combination of these properties to calculate the size of a window or document,\n\n      ```javascript\n      var width =\n        window.innerWidth ||\n        document.documentElement.clientWidth ||\n        document.body.clientWidth;\n\n      var height =\n        window.innerHeight ||\n        document.documentElement.clientHeight ||\n        document.body.clientHeight;\n      ```\n\n174."
    },
    {
      "text": "Can you apply chaining on conditional operator",
      "options": [
        {
          "text": "You can change inline style or classname of a HTML element using javascript DOM-manipulation\n\n      1",
          "is_correct": false
        },
        {
          "text": "There are 3 phases in the lifecycle of an event propagation in JavaScript,\n\n     1",
          "is_correct": false
        },
        {
          "text": "Arrow functions do not have an `arguments, super, this, or new",
          "is_correct": false
        },
        {
          "text": "Yes, you can apply chaining on conditional operators similar to **`if … else if … else if … else`** chain",
          "is_correct": true
        }
      ],
      "explanation": "Yes, you can apply chaining on conditional operators similar to **`if … else if … else if … else`** chain. The syntax is going to be as below,\n\n      ```javascript\n      function traceValue(someParam) {\n        return condition1\n          ? value1\n          : condition2\n          ? value2\n          : condition3\n          ? value3\n          : value4;\n      }\n\n      // The above conditional operator is equivalent to:\n\n      function traceValue(someParam) {\n        if (condition1) {\n          return value1;\n        } else if (condition2) {\n          return value2;\n        } else if (condition3) {\n          return value3;\n        } else {\n          return value4;\n        }\n      }\n      ```\n\n176."
    },
    {
      "text": "Can you give an example of when you really need a semicolon",
      "options": [
        {
          "text": "You need to use date",
          "is_correct": false
        },
        {
          "text": "V8 engine uses the below optimization techniques",
          "is_correct": false
        },
        {
          "text": "It is recommended to use semicolons after every statement in JavaScript",
          "is_correct": true
        },
        {
          "text": "is()` method determines whether two values are the same value",
          "is_correct": false
        }
      ],
      "explanation": "It is recommended to use semicolons after every statement in JavaScript. For example, in the below case (that is an IIFE = Immediately Invoked Function Expression) it throws an error \".. is not a function\" at runtime due to missing semicolon.\n\n      ```javascript\n      // define a function\n      var fn = (function () {\n        //...\n      })(\n        // semicolon missing at this line\n\n        // then execute some code inside a closure\n        function () {\n          //...\n        }\n      )();\n      ```\n\n      and it will be interpreted as\n\n      ```javascript\n      var fn = (function () {\n        //...\n      })(function () {\n        //...\n      })();\n      ```\n\n      In this case, we are passing the second function as an argument to the first function and then trying to call the result of the first function call as a function. Hence, the second function will fail with a \"... is not a function\" error at runtime.\n\n179."
    },
    {
      "text": "What is the freeze method",
      "options": [
        {
          "text": "You can use the `import",
          "is_correct": false
        },
        {
          "text": "The **`freeze()`** method is used to freeze an object",
          "is_correct": true
        },
        {
          "text": "You can use ECMAScript 6's `String",
          "is_correct": false
        },
        {
          "text": "The global execution context is the default or first execution context that is created by the JavaScript engine before any code is executed(i",
          "is_correct": false
        }
      ],
      "explanation": "The **`freeze()`** method is used to freeze an object. Freezing an object does not allow adding new properties to an object, prevents removing, and prevents changing the enumerability, configurability, or writability of existing properties. i.e. It returns the passed object and does not create a frozen copy.\n\n      ```javascript\n      const obj = {\n        prop: 100,\n      };\n\n      Object.freeze(obj);\n      obj.prop = 200; // Throws an error in strict mode\n\n      console.log(obj.prop); //100\n      ```\n\n      Remember freezing is only applied to the top-level properties in objects but not for nested objects.\n      For example, let's try to freeze user object which has employment details as nested object and observe that details have been changed.\n\n      ```javascript\n      const user = {\n        name: \"John\",\n        employment: {\n          department: \"IT\",\n        },\n      };\n\n      Object.freeze(user);\n      user.employment.department = \"HR\";\n      ```\n\n      **Note:** It causes a TypeError if the argument passed is not an object.\n\n180."
    },
    {
      "text": "Why do I need to use the freeze method",
      "options": [
        {
          "text": "In the Object-oriented paradigm, an existing API contains certain elements that are not intended to be extended, modified, or re-used outside of their current context",
          "is_correct": true
        },
        {
          "text": "TypeScript is a typed superset of JavaScript created by Microsoft that adds optional types, classes\n      and many other features, and compiles to plain JavaScript",
          "is_correct": false
        },
        {
          "text": "You can use the `getTimezoneOffset` method of the date object",
          "is_correct": false
        },
        {
          "text": "JavaScript provided a trim method on string types to trim any whitespaces present at the beginning or ending of the string",
          "is_correct": false
        }
      ],
      "explanation": "In the Object-oriented paradigm, an existing API contains certain elements that are not intended to be extended, modified, or re-used outside of their current context. Hence it works as the `final` keyword which is used in various languages.\n\n182."
    },
    {
      "text": "How do you detect a browser language preference",
      "options": [
        {
          "text": "Scope is the accessibility of variables, functions, and objects in some particular part of your code during runtime",
          "is_correct": false
        },
        {
          "text": "The value null represents the intentional absence of any object value",
          "is_correct": false
        },
        {
          "text": "In JavaScript, `call`, `apply`, and `bind` are methods that allow you to control the context (`this` value) in which a function is executed",
          "is_correct": false
        },
        {
          "text": "You can use the navigator object to detect a browser language preference as below,\n\n      **⬆ **\n\n183",
          "is_correct": true
        }
      ],
      "explanation": "You can use the navigator object to detect a browser language preference as below,\n\n      ```javascript\n      var language =\n        (navigator.languages && navigator.languages[0]) || // Chrome / Firefox\n        navigator.language || // All browsers\n        navigator.userLanguage; // IE <= 10\n\n      console.log(language);\n      ```\n\n183."
    },
    {
      "text": "How do you detect if javascript is disabled on the page",
      "options": [
        {
          "text": "`Native objects` are objects that are part of the JavaScript language defined by the ECMAScript specification",
          "is_correct": false
        },
        {
          "text": "You can use the `` tag to detect javascript disabled or not",
          "is_correct": true
        },
        {
          "text": "The super keyword is used to call methods of a superclass",
          "is_correct": false
        },
        {
          "text": "In ES6, Javascript classes are primarily syntactic sugar over JavaScript’s existing prototype-based inheritance",
          "is_correct": false
        }
      ],
      "explanation": "You can use the `` tag to detect javascript disabled or not. The code block inside `` gets executed when JavaScript is disabled, and is typically used to display alternative content when the page generated in JavaScript.\n\n      ```javascript\n      \n          // JS related code goes here\n\n          JavaScript is disabled in the page. Please click Next Page\n      \n      ```\n\n185."
    },
    {
      "text": "How do you determine whether object is frozen or not",
      "options": [
        {
          "text": "JavaScript is a loosely typed or a dynamic language because variables in JavaScript are not directly associated with any particular value type, and any variable can be assigned/reassigned with values of all types",
          "is_correct": false
        },
        {
          "text": "The global execution context is the default or first execution context that is created by the JavaScript engine before any code is executed(i",
          "is_correct": false
        },
        {
          "text": "isFrozen()` method is used to determine if an object is frozen or not",
          "is_correct": true
        },
        {
          "text": "is()` method determines whether two values are the same value",
          "is_correct": false
        }
      ],
      "explanation": "`Object.isFrozen()` method is used to determine if an object is frozen or not.An object is frozen if all of the below conditions hold true,\n\n      1. If it is not extensible.\n      2. If all of its properties are non-configurable.\n      3. If all its data properties are non-writable.\n         The usage is going to be as follows,\n\n      ```javascript\n      const object = {\n        property: \"Welcome JS world\",\n      };\n      Object.freeze(object);\n      console.log(Object.isFrozen(object));\n      ```\n\n191."
    },
    {
      "text": "How do you determine two values same or not using object",
      "options": [
        {
          "text": "The typeof operator on any primitive returns a string value",
          "is_correct": false
        },
        {
          "text": "**Parsing**: Transforming a JSON-formatted string into a native JavaScript object",
          "is_correct": false
        },
        {
          "text": "In vanilla javascript, you can redirect to a new page using the `location` property of window object",
          "is_correct": false
        },
        {
          "text": "is()` method determines whether two values are the same value",
          "is_correct": true
        }
      ],
      "explanation": "The `Object.is()` method determines whether two values are the same value. For example, the usage with different types of values would be,\n\n      ```javascript\n      Object.is(\"hello\", \"hello\"); // true\n      Object.is(window, window); // true\n      Object.is([], []); // false\n      ```\n\n      Two values are considered identical if one of the following holds:\n\n      1. both undefined\n      2. both null\n      3. both true or both false\n      4. both strings of the same length with the same characters in the same order\n      5. both the same object (means both object have same reference)\n      6. both numbers and\n         both +0\n         both -0\n         both NaN\n         both non-zero and both not NaN and both have the same value.\n\n192."
    },
    {
      "text": "What is the purpose of using object is method",
      "options": [
        {
          "text": "Module pattern is a designed pattern used to wrap a set of variables and functions together in a single scope returned as an object",
          "is_correct": false
        },
        {
          "text": "You can use the `for-in` loop to loop through javascript object",
          "is_correct": false
        },
        {
          "text": "There are 3 possible ways to check whether a string contains a substring or not,\n\n      1",
          "is_correct": false
        },
        {
          "text": "Some of the applications of Object's `is` method are follows,\n\n      1",
          "is_correct": true
        }
      ],
      "explanation": "Some of the applications of Object's `is` method are follows,\n\n      1. It is used for comparison of two strings.\n      2. It is used for comparison of two numbers.\n      3. It is used for comparing the polarity of two numbers.\n      4. It is used for comparison of two objects.\n\n193."
    },
    {
      "text": "How do you copy properties from one object to other",
      "options": [
        {
          "text": "Web storage is an API that provides a mechanism by which browsers can store key/value pairs locally within the user's browser, in a much more intuitive fashion than using cookies",
          "is_correct": false
        },
        {
          "text": "You can use the `Object",
          "is_correct": true
        },
        {
          "text": "The custom bind function needs to be created on Function prototype inorder to use it as other builtin functions",
          "is_correct": false
        },
        {
          "text": "You can use `new Date()` to generate a new Date object containing the current date and time",
          "is_correct": false
        }
      ],
      "explanation": "You can use the `Object.assign()` method which is used to copy the values and properties from one or more source objects to a target object. It returns the target object which has properties and values copied from the source objects. The syntax would be as below,\n\n      ```javascript\n      Object.assign(target, ...sources);\n      ```\n\n      Let's take example with one source and one target object,\n\n      ```javascript\n      const target = { a: 1, b: 2 };\n      const source = { b: 3, c: 4 };\n\n      const returnedTarget = Object.assign(target, source);\n\n      console.log(target); // { a: 1, b: 3, c: 4 }\n\n      console.log(returnedTarget); // { a: 1, b: 3, c: 4 }\n      ```\n\n      As observed in the above code, there is a common property(`b`) from source to target so it's value has been overwritten.\n\n194."
    },
    {
      "text": "What are the applications of the assign method",
      "options": [
        {
          "text": "Below are the some of main applications of `Object",
          "is_correct": true
        },
        {
          "text": "IIFE(Immediately Invoked Function Expression) is just like any other function expression which won't be hoisted",
          "is_correct": false
        },
        {
          "text": "Yes, JavaScript is a case sensitive language",
          "is_correct": false
        },
        {
          "text": "The function's object has a **length** property which tells you how many formal parameters expected by a function",
          "is_correct": false
        }
      ],
      "explanation": "Below are the some of main applications of `Object.assign()` method,\n\n      1. It is used for cloning an object.\n      2. It is used to merge objects with the same properties.\n\n195."
    },
    {
      "text": "What is the purpose of the seal method",
      "options": [
        {
          "text": "You can use the `String",
          "is_correct": false
        },
        {
          "text": "seal()` method is used to seal an object, by preventing new properties from being added to it and marking all existing properties as non-configurable",
          "is_correct": true
        },
        {
          "text": "Below are the list of placeholders available from console object,\n\n      1",
          "is_correct": false
        },
        {
          "text": "You can use the `Number",
          "is_correct": false
        }
      ],
      "explanation": "The `Object.seal()` method is used to seal an object, by preventing new properties from being added to it and marking all existing properties as non-configurable. But **values of present properties can still be changed as long as they are writable**. The next level of immutability would be the [`Object.freeze()`](#what-is-a-freeze-method) method. Let's see the below example to understand more about `seal()` method\n\n      ```javascript\n      const object = {\n        property: \"Welcome JS world\",\n      };\n      Object.seal(object);\n      object.property = \"Welcome to object world\";\n      console.log(Object.isSealed(object)); // true\n      delete object.property; // You cannot delete when sealed\n      console.log(object.property); //Welcome to object world\n      ```\n\n197."
    },
    {
      "text": "What are the differences between the freeze and seal methods",
      "options": [
        {
          "text": "RegExp object is a regular expression object with predefined properties and methods",
          "is_correct": false
        },
        {
          "text": "If an object is frozen using the `Object",
          "is_correct": true
        },
        {
          "text": "Arrow functions do not have an `arguments, super, this, or new",
          "is_correct": false
        },
        {
          "text": "`Symbol` is a just a standard function and not an object constructor(unlike other primitives new Boolean, new String and new Number)",
          "is_correct": false
        }
      ],
      "explanation": "If an object is frozen using the `Object.freeze()` method then its properties become immutable and no changes can be made in them whereas if an object is sealed using the `Object.seal()` method then the changes can be made in the existing properties of the object.\n\n199."
    },
    {
      "text": "How do you determine if an object is sealed or not",
      "options": [
        {
          "text": "The `window` object provides a `print()` method which is used to print the contents of the current window",
          "is_correct": false
        },
        {
          "text": "The functions which are created with `Function constructor` do not create closures to their creation contexts but they are always created in the global scope",
          "is_correct": false
        },
        {
          "text": "isSealed()` method is used to determine if an object is sealed or not",
          "is_correct": true
        },
        {
          "text": "Even though JavaScript lacks namespaces, we can use Objects, an IIFE (Immediately Invoked Function Expression) or `let`/`const` to create namespaces",
          "is_correct": false
        }
      ],
      "explanation": "The `Object.isSealed()` method is used to determine if an object is sealed or not. An object is sealed if all of the below conditions hold true\n\n      1. If it is not extensible.\n      2. If all of its properties are non-configurable.\n      3. If it is not removable (but not necessarily non-writable).\n         Let's see it in the action\n\n      ```javascript\n      const object = {\n        property: \"Hello, Good morning\",\n      };\n\n      Object.seal(object); // Using seal() method to seal the object\n\n      console.log(Object.isSealed(object)); // checking whether the object is sealed or not\n      ```\n\n200."
    },
    {
      "text": "How do you create an object with a prototype",
      "options": [
        {
          "text": "The function `printHello` is hoisted to the top of the global scope and prints \"Hello\" to the console",
          "is_correct": false
        },
        {
          "text": "Below are the some of main applications of `Object",
          "is_correct": false
        },
        {
          "text": "The `uneval()` is an builtin function which is used to create a string representation of the source code of an Object",
          "is_correct": false
        },
        {
          "text": "create()` method is used to create a new object with the specified prototype object and properties",
          "is_correct": true
        }
      ],
      "explanation": "The `Object.create()` method is used to create a new object with the specified prototype object and properties. i.e, It uses an existing object as the prototype of the newly created object. It returns a new object with the specified prototype object and properties.\n\n      ```javascript\n      const user = {\n        name: \"John\",\n        printInfo: function () {\n          console.log(`My name is ${this.name}.`);\n        },\n      };\n\n      const admin = Object.create(user);\n\n      admin.name = \"Nick\"; // Remember that \"name\" is a property set on \"admin\" but not on \"user\" object\n\n      admin.printInfo(); // My name is Nick\n      ```\n\n204."
    },
    {
      "text": "What is a WeakSet",
      "options": [
        {
          "text": "defineProperty()` static method is used to define a new property directly on an object, or modify an existing property on an object, and returns the object",
          "is_correct": false
        },
        {
          "text": "Event capturing is a phase of event propagation in which an event is first intercepted by the outermost ancestor element, then travels downward through the DOM hierarchy until it reaches the target (innermost) element",
          "is_correct": false
        },
        {
          "text": "According to MDN official docs, the optional chaining operator (?",
          "is_correct": false
        },
        {
          "text": "A `WeakSet` is used to store a collection of weakly(weak references) held objects",
          "is_correct": true
        }
      ],
      "explanation": "A `WeakSet` is used to store a collection of weakly(weak references) held objects. The syntax would be as follows,\n\n      ```javascript\n      new WeakSet([iterable]);\n      ```\n\n      Let's see the below example to explain it's behavior,\n\n      ```javascript\n      var ws = new WeakSet();\n      var user = {};\n      ws.add(user);\n      ws.has(user); // true\n      ws.delete(user); // removes user from the set\n      ws.has(user); // false, user has been removed\n      ```\n\n205."
    },
    {
      "text": "What are the differences between WeakSet and Set",
      "options": [
        {
          "text": "The main difference is that references to objects in `Set` are strong while references to objects in `WeakSet` are weak",
          "is_correct": true
        },
        {
          "text": "You can apply the `checked` property on the selected checkbox in the DOM",
          "is_correct": false
        },
        {
          "text": "Yes, You can use the `Object",
          "is_correct": false
        },
        {
          "text": "You can check whether a key exists in an object or not using three approaches,\n\n      1",
          "is_correct": false
        }
      ],
      "explanation": "The main difference is that references to objects in `Set` are strong while references to objects in `WeakSet` are weak. i.e, An object in `WeakSet` can be garbage collected if there is no other reference to it.\n      Other differences are:\n\n      1. `Set` can store any value whereas `WeakSet` can store only collections of objects\n      2. `WeakSet` does not have size property unlike `Set`\n      3. `WeakSet` does not have methods such as clear, keys, values, entries, forEach.\n      4. `WeakSet` is not iterable.\n\n206."
    },
    {
      "text": "List down the collection of methods available on WeakSet",
      "options": [
        {
          "text": "JavaScript does not have built-in support for mixins as a formal language feature",
          "is_correct": false
        },
        {
          "text": "defineProperty()` static method is used to define a new property directly on an object, or modify an existing property on an object, and returns the object",
          "is_correct": false
        },
        {
          "text": "The constructor method is a special method for creating and initializing an object created within a class",
          "is_correct": false
        },
        {
          "text": "Below are the list of methods available on `WeakSet`,\n\n      1",
          "is_correct": true
        }
      ],
      "explanation": "Below are the list of methods available on `WeakSet`,\n\n      1. `add(value)`: A new object is appended with the given value\n      2. `delete(value)`: Deletes the value from the collection.\n      3. `has(value)`: It returns true if the value is present in the collection, otherwise it returns false.\n\n      Let's see the functionality of all the above methods in an example,\n\n      ```javascript\n      var weakSetObject = new WeakSet();\n      var firstObject = {};\n      var secondObject = {};\n      // add(value)\n      weakSetObject.add(firstObject);\n      weakSetObject.add(secondObject);\n      console.log(weakSetObject.has(firstObject)); //true\n      weakSetObject.delete(secondObject);\n      ```\n\n207."
    },
    {
      "text": "What is the purpose of uneval",
      "options": [
        {
          "text": "The Instance properties must be defined inside of class methods",
          "is_correct": false
        },
        {
          "text": "The `uneval()` is an builtin function which is used to create a string representation of the source code of an Object",
          "is_correct": true
        },
        {
          "text": "If a function is called with `undefined`, the `undefined` value is treated as a parameter",
          "is_correct": false
        },
        {
          "text": "`this` keyword is dynamic scoped but not lexically scoped",
          "is_correct": false
        }
      ],
      "explanation": "The `uneval()` is an builtin function which is used to create a string representation of the source code of an Object. It is a top-level function and is not associated with any object. Let's see the below example to know more about it's functionality,\n\n      ```javascript\n      var a = 1;\n      uneval(a); // returns a String containing 1\n      uneval(function user() {}); // returns \"(function user(){})\"\n      ```\n\n      The `uneval()` function has been deprecated. It is recommended to use `toString()` for functions and `JSON.stringify()` for other cases.\n\n      ```javascript\n      function user() {}\n      console.log(user.toString()); // returns \"(function user(){})\"\n      ```\n\n211."
    },
    {
      "text": "How do you print the contents of web page",
      "options": [
        {
          "text": "You can use the `for-in` loop to loop through javascript object",
          "is_correct": false
        },
        {
          "text": "isSealed()` method is used to determine if an object is sealed or not",
          "is_correct": false
        },
        {
          "text": "In order to be consistent with functions like `String",
          "is_correct": false
        },
        {
          "text": "The `window` object provides a `print()` method which is used to print the contents of the current window",
          "is_correct": true
        }
      ],
      "explanation": "The `window` object provides a `print()` method which is used to print the contents of the current window. It opens a Print dialog box which lets you choose between various printing options. Let's see the usage of print method in an example,\n\n      ```html\n      \n      ```\n\n      **Note:** In most browsers, it will block while the print dialog is open.\n\n214."
    },
    {
      "text": "What is the difference between uneval and eval",
      "options": [
        {
          "text": "The function `printHello` is hoisted to the top of the global scope and prints \"Hello\" to the console",
          "is_correct": false
        },
        {
          "text": "target` pseudo-property to detect whether a function was called as a constructor(using the new operator) or as a regular function call",
          "is_correct": false
        },
        {
          "text": "According to MDN official docs, the optional chaining operator (?",
          "is_correct": false
        },
        {
          "text": "The `uneval` function returns the source of a given object; whereas the `eval` function does the opposite, by evaluating that source code in a different memory area",
          "is_correct": true
        }
      ],
      "explanation": "The `uneval` function returns the source of a given object; whereas the `eval` function does the opposite, by evaluating that source code in a different memory area. Let's see an example to clarify the difference,\n\n      ```javascript\n      var msg = uneval(function greeting() {\n        return \"Hello, Good morning\";\n      });\n      var greeting = eval(msg);\n      greeting(); // returns \"Hello, Good morning\"\n      ```\n\n215."
    },
    {
      "text": "What are javascript accessors",
      "options": [
        {
          "text": "ECMAScript 5 introduced javascript object accessors or computed properties through getters and setters",
          "is_correct": true
        },
        {
          "text": "Each context(global or functional) has it's own variable environment and the callstack of variables in a LIFO order",
          "is_correct": false
        },
        {
          "text": "You can use the `String",
          "is_correct": false
        },
        {
          "text": "Currying** is the process of transforming a function with **multiple arguments** into a sequence of **nested functions**, each accepting **only one argument** at a time",
          "is_correct": false
        }
      ],
      "explanation": "ECMAScript 5 introduced javascript object accessors or computed properties through getters and setters. Getters uses the `get` keyword whereas Setters uses the `set` keyword.\n\n      ```javascript\n      var user = {\n        firstName: \"John\",\n        lastName: \"Abraham\",\n        language: \"en\",\n        get lang() {\n          return this.language;\n        },\n        set lang(lang) {\n          this.language = lang;\n        },\n      };\n      console.log(user.lang); // getter access lang as en\n      user.lang = \"fr\";\n      console.log(user.lang); // setter used to set lang as fr\n      ```\n\n218."
    },
    {
      "text": "How do you define property on Object constructor",
      "options": [
        {
          "text": "JavaScript is a loosely typed or a dynamic language because variables in JavaScript are not directly associated with any particular value type, and any variable can be assigned/reassigned with values of all types",
          "is_correct": false
        },
        {
          "text": "According to ECMAScript specification 262 (9",
          "is_correct": false
        },
        {
          "text": "defineProperty()` static method is used to define a new property directly on an object, or modify an existing property on an object, and returns the object",
          "is_correct": true
        },
        {
          "text": "The type of operator on new Number always returns object",
          "is_correct": false
        }
      ],
      "explanation": "The `Object.defineProperty()` static method is used to define a new property directly on an object, or modify an existing property on an object, and returns the object. Let's see an example to know how to define property,\n\n      ```javascript\n      const newObject = {};\n\n      Object.defineProperty(newObject, \"newProperty\", {\n        value: 100,\n        writable: false,\n      });\n\n      console.log(newObject.newProperty); // 100\n\n      newObject.newProperty = 200; // It throws an error in strict mode due to writable setting\n      ```\n\n219."
    },
    {
      "text": "What is the difference between get and defineProperty",
      "options": [
        {
          "text": "TypeScript is a typed superset of JavaScript created by Microsoft that adds optional types, classes\n      and many other features, and compiles to plain JavaScript",
          "is_correct": false
        },
        {
          "text": "Both have similar results unless you use classes",
          "is_correct": true
        },
        {
          "text": "In JavaScript, `call`, `apply`, and `bind` are methods that allow you to control the context (`this` value) in which a function is executed",
          "is_correct": false
        },
        {
          "text": "There are two possible solutions to add new properties to an object",
          "is_correct": false
        }
      ],
      "explanation": "Both have similar results unless you use classes. If you use `get` the property will be defined on the prototype of the object whereas using `Object.defineProperty()` the property will be defined on the instance it is applied to.\n\n220."
    },
    {
      "text": "Can I add getters and setters using defineProperty method",
      "options": [
        {
          "text": "Yes, You can use the `Object",
          "is_correct": true
        },
        {
          "text": "Event flow refers to the order in which events are handled in the browser when a user interacts with elements on a webpage like clicking, typing, hovering, etc",
          "is_correct": false
        },
        {
          "text": "Generators are not constructible type",
          "is_correct": false
        },
        {
          "text": "The global execution context is the default or first execution context that is created by the JavaScript engine before any code is executed(i",
          "is_correct": false
        }
      ],
      "explanation": "Yes, You can use the `Object.defineProperty()` method to add Getters and Setters. For example, the below counter object uses increment, decrement, add and subtract properties,\n\n      ```javascript\n      var obj = { counter: 0 };\n\n      // Define getters\n      Object.defineProperty(obj, \"increment\", {\n        get: function () {\n          this.counter++;\n          return this.counter;\n        },\n      });\n      Object.defineProperty(obj, \"decrement\", {\n        get: function () {\n          this.counter--;\n          return this.counter;\n        },\n      });\n\n      // Define setters\n      Object.defineProperty(obj, \"add\", {\n        set: function (value) {\n          this.counter += value;\n        },\n      });\n      Object.defineProperty(obj, \"subtract\", {\n        set: function (value) {\n          this.counter -= value;\n        },\n      });\n\n      obj.add = 10;\n      obj.subtract = 5;\n      console.log(obj.increment); //6\n      console.log(obj.decrement); //5\n      ```\n\n222."
    },
    {
      "text": "What are the different ways to access object properties",
      "options": [
        {
          "text": "You can use the `` tag to detect javascript disabled or not",
          "is_correct": false
        },
        {
          "text": "You can use the navigator object to detect a browser language preference as below,\n\n      **⬆ **\n\n183",
          "is_correct": false
        },
        {
          "text": "There are 3 possible ways for accessing the property of an object",
          "is_correct": true
        },
        {
          "text": "The `repeat()` method is used to construct and return a new string which contains the specified number of copies of the string on which it was called, concatenated together",
          "is_correct": false
        }
      ],
      "explanation": "There are 3 possible ways for accessing the property of an object.\n\n      1. **Dot notation:** It uses dot for accessing the properties\n\n      ```javascript\n      objectName.property;\n      ```\n\n      2. **Square brackets notation:** It uses square brackets for property access\n\n      ```javascript\n      objectName[\"property\"];\n      ```\n\n      3. **Expression notation:** It uses expression in the square brackets\n\n      ```javascript\n      objectName[expression];\n      ```\n\n226."
    },
    {
      "text": "What is an error object",
      "options": [
        {
          "text": "An error object is a built in error object that provides error information when an error occurs",
          "is_correct": true
        },
        {
          "text": "When you apply 'use strict'; syntax, some of the below cases will throw a SyntaxError before executing the script\n\n      1",
          "is_correct": false
        },
        {
          "text": "The `repeat()` method is used to construct and return a new string which contains the specified number of copies of the string on which it was called, concatenated together",
          "is_correct": false
        },
        {
          "text": "Yes, JavaScript is a case sensitive language",
          "is_correct": false
        }
      ],
      "explanation": "An error object is a built in error object that provides error information when an error occurs. It has two properties: name and message. For example, the below function logs error details,\n\n      ```javascript\n      try {\n        greeting(\"Welcome\");\n      } catch (err) {\n        console.log(err.name + \"\" + err.message);\n      }\n      ```\n\n228."
    },
    {
      "text": "What is the Intl object",
      "options": [
        {
          "text": "If you leave out the right-hand side assignment for the destructuring object, the function will look for at least one argument to be supplied when invoked",
          "is_correct": false
        },
        {
          "text": "The `Intl` object is the namespace for the ECMAScript Internationalization API, which provides language sensitive string comparison, number formatting, and date and time formatting",
          "is_correct": true
        },
        {
          "text": "ES6 provides method definitions and property shorthands for objects",
          "is_correct": false
        },
        {
          "text": "Web storage is an API that provides a mechanism by which browsers can store key/value pairs locally within the user's browser, in a much more intuitive fashion than using cookies",
          "is_correct": false
        }
      ],
      "explanation": "The `Intl` object is the namespace for the ECMAScript Internationalization API, which provides language sensitive string comparison, number formatting, and date and time formatting. It provides access to several constructors and language sensitive functions.\n\n234."
    },
    {
      "text": "How do you perform language specific date and time formatting",
      "options": [
        {
          "text": "The global execution context is the default or first execution context that is created by the JavaScript engine before any code is executed(i",
          "is_correct": false
        },
        {
          "text": "The Error constructor creates an error object and the instances of error objects are thrown when runtime errors occur",
          "is_correct": false
        },
        {
          "text": "First, we should know about tail call before talking about \"Proper Tail Call\"",
          "is_correct": false
        },
        {
          "text": "You can use the `Intl",
          "is_correct": true
        }
      ],
      "explanation": "You can use the `Intl.DateTimeFormat` object which is a constructor for objects that enable language-sensitive date and time formatting. Let's see this behavior with an example,\n\n      ```javascript\n      var date = new Date(Date.UTC(2019, 07, 07, 3, 0, 0));\n      console.log(new Intl.DateTimeFormat(\"en-GB\").format(date)); // 07/08/2019\n      console.log(new Intl.DateTimeFormat(\"en-AU\").format(date)); // 07/08/2019\n      ```\n\n235."
    },
    {
      "text": "What is an Iterator",
      "options": [
        {
          "text": "An iterator is an object which defines a sequence and a return value upon its termination",
          "is_correct": true
        },
        {
          "text": "Both have similar results unless you use classes",
          "is_correct": false
        },
        {
          "text": "If an object is frozen using the `Object",
          "is_correct": false
        },
        {
          "text": "A decorator is an expression that evaluates to a function and that takes the target, name, and decorator descriptor as arguments",
          "is_correct": false
        }
      ],
      "explanation": "An iterator is an object which defines a sequence and a return value upon its termination. It implements the Iterator protocol with a `next()` method which returns an object with two properties: `value` (the next value in the sequence) and `done` (which is true if the last value in the sequence has been consumed).\n\n236."
    },
    {
      "text": "What is a decorator",
      "options": [
        {
          "text": "You can use the `super` keyword to call the constructor of a parent class",
          "is_correct": false
        },
        {
          "text": "A decorator is an expression that evaluates to a function and that takes the target, name, and decorator descriptor as arguments",
          "is_correct": true
        },
        {
          "text": "Since JavaScript is a dynamic programming language, you can add or remove properties and methods from objects on the fly at runtime",
          "is_correct": false
        },
        {
          "text": "When receiving the data from a web server, the data is always in a string format",
          "is_correct": false
        }
      ],
      "explanation": "A decorator is an expression that evaluates to a function and that takes the target, name, and decorator descriptor as arguments. Also, it optionally returns a decorator descriptor to install on the target object. Let's define admin decorator for user class at design time,\n\n      ```javascript\n      function admin(isAdmin) {\n         return function(target) {\n             target.isAdmin = isAdmin;\n         }\n      }\n\n      @admin(true)\n      class User() {\n      }\n      console.log(User.isAdmin); //true\n\n       @admin(false)\n       class User() {\n       }\n       console.log(User.isAdmin); //false\n      ```\n\n241."
    },
    {
      "text": "What are the properties of the Intl object",
      "options": [
        {
          "text": "JavaScript does not have built-in support for mixins as a formal language feature",
          "is_correct": false
        },
        {
          "text": "There are two possible solutions to add new properties to an object",
          "is_correct": false
        },
        {
          "text": "Below are the list of properties available on the `Intl` object,\n\n      1",
          "is_correct": true
        },
        {
          "text": "The EvalError object indicates an error regarding the global `eval()` function",
          "is_correct": false
        }
      ],
      "explanation": "Below are the list of properties available on the `Intl` object,\n\n      1. **Collator:** These are the objects that enable language-sensitive string comparison.\n      2. **DateTimeFormat:** These are the objects that enable language-sensitive date and time formatting.\n      3. **ListFormat:** These are the objects that enable language-sensitive list formatting.\n      4. **NumberFormat:** Objects that enable language-sensitive number formatting.\n      5. **PluralRules:** Objects that enable plural-sensitive formatting and language-specific rules for plurals.\n      6. **RelativeTimeFormat:** Objects that enable language-sensitive relative time formatting.\n\n242."
    },
    {
      "text": "How do you get the metadata of a module",
      "options": [
        {
          "text": "The global execution context is the default or first execution context that is created by the JavaScript engine before any code is executed(i",
          "is_correct": false
        },
        {
          "text": "Unlike function declarations, class declarations are not hoisted",
          "is_correct": false
        },
        {
          "text": "You can use the `import",
          "is_correct": true
        },
        {
          "text": "There are different solutions based on ECMAScript versions\n\n      1",
          "is_correct": false
        }
      ],
      "explanation": "You can use the `import.meta` object which is a meta-property exposing context-specific meta data to a JavaScript module. It contains information about the current module, such as the module's URL. In browsers, you might get different meta data than NodeJS.\n\n      ```javascript\n      ;\n      console.log(import.meta); // { url: \"file:///home/user/welcome-module.js\" }\n      ```\n\n250."
    },
    {
      "text": "What is typescript",
      "options": [
        {
          "text": "Inline caching is an optimization technique based on the observation that repeated calls to same function tends to occur on same type of objects",
          "is_correct": false
        },
        {
          "text": "An expression in javascript that can be replaced by its value without affecting the behaviour of the program is called referential transparency",
          "is_correct": false
        },
        {
          "text": "TypeScript is a typed superset of JavaScript created by Microsoft that adds optional types, classes\n      and many other features, and compiles to plain JavaScript",
          "is_correct": true
        },
        {
          "text": "You need to use date",
          "is_correct": false
        }
      ],
      "explanation": "TypeScript is a typed superset of JavaScript created by Microsoft that adds optional types, classes\n      and many other features, and compiles to plain JavaScript. Angular is built entirely in TypeScript and it is used as the primary language there. You can install it globally as\n\n      ```bash\n      npm install -g typescript\n      ```\n\n      Let's see a simple example of TypeScript usage,\n\n      ```typescript\n      function greeting(name: string): string {\n        return \"Hello, \" + name;\n      }\n\n      let user = \"Sudheer\";\n\n      console.log(greeting(user));\n      ```\n\n      The greeting method allows only string type as argument.\n\n253."
    },
    {
      "text": "What is an object initializer",
      "options": [
        {
          "text": "There are different solutions based on ECMAScript versions\n\n      1",
          "is_correct": false
        },
        {
          "text": "An object initializer is an expression that describes the initialization of an Object",
          "is_correct": true
        },
        {
          "text": "Code snippet:**\n\n      **Output:**\n\n      The output is 40 and NaN",
          "is_correct": false
        },
        {
          "text": "You can use the `Object",
          "is_correct": false
        }
      ],
      "explanation": "An object initializer is an expression that describes the initialization of an Object. The syntax for this expression is represented as a comma-delimited list of zero or more pairs of property names and associated values of an object, enclosed in curly braces ({}). This is also known as literal notation. It is one of the ways to create an object.\n\n      ```javascript\n      var initObject = { a: \"John\", b: 50, c: {} };\n\n      console.log(initObject.a); // John\n      ```\n\n256."
    },
    {
      "text": "What is a constructor method",
      "options": [
        {
          "text": "The \"constructor\" in a class is a special method and it should be defined only once in a class",
          "is_correct": false
        },
        {
          "text": "Below are the list of placeholders available from console object,\n\n      1",
          "is_correct": false
        },
        {
          "text": "The constructor method is a special method for creating and initializing an object created within a class",
          "is_correct": true
        },
        {
          "text": "The Browser Object Model (BOM) allows JavaScript to \"talk to\" the browser",
          "is_correct": false
        }
      ],
      "explanation": "The constructor method is a special method for creating and initializing an object created within a class. If you do not specify a constructor method, a default constructor is used. The example usage of constructor would be as below,\n\n      ```javascript\n      class Employee {\n        constructor() {\n          this.name = \"John\";\n        }\n      }\n\n      var employeeObject = new Employee();\n\n      console.log(employeeObject.name); // John\n      ```\n\n257."
    },
    {
      "text": "What happens if you write constructor more than once in a class",
      "options": [
        {
          "text": "The \"constructor\" in a class is a special method and it should be defined only once in a class",
          "is_correct": true
        },
        {
          "text": "The `uneval` function returns the source of a given object; whereas the `eval` function does the opposite, by evaluating that source code in a different memory area",
          "is_correct": false
        },
        {
          "text": "Each context(global or functional) has it's own variable environment and the callstack of variables in a LIFO order",
          "is_correct": false
        },
        {
          "text": "The typeof operator on any primitive returns a string value",
          "is_correct": false
        }
      ],
      "explanation": "The \"constructor\" in a class is a special method and it should be defined only once in a class. i.e, If you write a constructor method more than once in a class it will throw a `SyntaxError` error.\n\n      ```javascript\n       class Employee {\n         constructor() {\n           this.name = \"John\";\n         }\n         constructor() {   //  Uncaught SyntaxError: A class may only have one constructor\n           this.age = 30;\n         }\n       }\n\n       var employeeObject = new Employee();\n\n       console.log(employeeObject.name);\n      ```\n\n      This constructor is called by using the special function call `new` (see example above).\n\n258."
    },
    {
      "text": "How do you call the constructor of a parent class",
      "options": [
        {
          "text": "dir()` is used to display an interactive list of the properties of the specified JavaScript object as JSON",
          "is_correct": false
        },
        {
          "text": "You can use the `super` keyword to call the constructor of a parent class",
          "is_correct": true
        },
        {
          "text": "The main points in the above code snippets are,\n\n1",
          "is_correct": false
        },
        {
          "text": "You can use innerWidth, innerHeight, clientWidth, clientHeight properties of windows, document element and document body objects to find the size of a window",
          "is_correct": false
        }
      ],
      "explanation": "You can use the `super` keyword to call the constructor of a parent class. Remember that `super()` must be called before using `this` reference. Otherwise it will cause a reference error. Let's the usage of it,\n\n      ```javascript\n      class Square extends Rectangle {\n        constructor(length) {\n          super(length, length);\n          this.name = \"Square\";\n        }\n\n        get area() {\n          return this.width * this.height;\n        }\n\n        set area(value) {\n          this.area = value;\n        }\n      }\n      ```\n\n259."
    },
    {
      "text": "How do you get the prototype of an object",
      "options": [
        {
          "text": "It is recommended to use semicolons after every statement in JavaScript",
          "is_correct": false
        },
        {
          "text": "Since `Set` object is a collection of unique values, it won't allow duplicate values in the collection",
          "is_correct": false
        },
        {
          "text": "When sending data to a web server, the data has to be in a string format",
          "is_correct": false
        },
        {
          "text": "You can use the `Object",
          "is_correct": true
        }
      ],
      "explanation": "You can use the `Object.getPrototypeOf(obj)` method to return the prototype of the specified object. i.e. The value of the internal `prototype` property. If there are no inherited properties then `null` value is returned.\n\n      ```javascript\n      const newPrototype = {};\n      const newObject = Object.create(newPrototype);\n\n      console.log(Object.getPrototypeOf(newObject) === newPrototype); // true\n      ```\n\n260."
    },
    {
      "text": "What happens If I pass string type for getPrototype method",
      "options": [
        {
          "text": "Cookies are used to remember information about the user profile(such as username)",
          "is_correct": false
        },
        {
          "text": "`Native objects` are objects that are part of the JavaScript language defined by the ECMAScript specification",
          "is_correct": false
        },
        {
          "text": "You can use the `Object",
          "is_correct": false
        },
        {
          "text": "In ES5, it will throw a TypeError exception if the obj parameter isn't an object",
          "is_correct": true
        }
      ],
      "explanation": "In ES5, it will throw a TypeError exception if the obj parameter isn't an object. Whereas in ES2015, the parameter will be coerced to an `Object`.\n\n      ```javascript\n      // ES5\n      Object.getPrototypeOf(\"James\"); // TypeError: \"James\" is not an object\n      // ES2015\n      Object.getPrototypeOf(\"James\"); // String.prototype\n      ```\n\n261."
    },
    {
      "text": "How do you set the prototype of one object to another",
      "options": [
        {
          "text": "You can use ECMAScript 6's `String",
          "is_correct": false
        },
        {
          "text": "The Error constructor creates an error object and the instances of error objects are thrown when runtime errors occur",
          "is_correct": false
        },
        {
          "text": "You can use the `Object",
          "is_correct": true
        },
        {
          "text": "Yes, you can apply chaining on conditional operators similar to **`if … else if … else if … else`** chain",
          "is_correct": false
        }
      ],
      "explanation": "You can use the `Object.setPrototypeOf()` method that sets the prototype (i.e., the internal `Prototype` property) of a specified object to another object or null. For example, if you want to set prototype of a square object to rectangle object would be as follows,\n\n      ```javascript\n      Object.setPrototypeOf(Square.prototype, Rectangle.prototype);\n      Object.setPrototypeOf({}, null);\n      ```\n\n262."
    },
    {
      "text": "How do you check whether an object can be extended or not",
      "options": [
        {
          "text": "In ES5, it will throw a TypeError exception if the obj parameter isn't an object",
          "is_correct": false
        },
        {
          "text": "The `Intl` object is the namespace for the ECMAScript Internationalization API, which provides language sensitive string comparison, number formatting, and date and time formatting",
          "is_correct": false
        },
        {
          "text": "isExtensible()` method is used to determine if an object is extendable or not",
          "is_correct": true
        },
        {
          "text": "The function `printHello` is hoisted to the top of the global scope and prints \"Hello\" to the console",
          "is_correct": false
        }
      ],
      "explanation": "The `Object.isExtensible()` method is used to determine if an object is extendable or not. i.e, Whether it can have new properties added to it or not.\n\n      ```javascript\n      const newObject = {};\n      console.log(Object.isExtensible(newObject)); //true\n      ```\n\n      **Note:** By default, all the objects are extendable. i.e, The new properties can be added or modified.\n\n263."
    },
    {
      "text": "How do you prevent an object from being extend",
      "options": [
        {
          "text": "**Parsing**: Transforming a JSON-formatted string into a native JavaScript object",
          "is_correct": false
        },
        {
          "text": "Each context(global or functional) has it's own variable environment and the callstack of variables in a LIFO order",
          "is_correct": false
        },
        {
          "text": "preventExtensions()` method is used to prevent new properties from ever being added to an object",
          "is_correct": true
        },
        {
          "text": "The `Intl` object is the namespace for the ECMAScript Internationalization API, which provides language sensitive string comparison, number formatting, and date and time formatting",
          "is_correct": false
        }
      ],
      "explanation": "The `Object.preventExtensions()` method is used to prevent new properties from ever being added to an object. In other words, it prevents future extensions to the object. Let's see the usage of this property,\n\n      ```javascript\n      const newObject = {};\n      Object.preventExtensions(newObject); // NOT extendable\n\n      try {\n        Object.defineProperty(newObject, \"newProperty\", {\n          // Adding new property\n          value: 100,\n        });\n      } catch (e) {\n        console.log(e); // TypeError: Cannot define property newProperty, object is not extensible\n      }\n      ```\n\n264."
    },
    {
      "text": "What are the different ways to make an object non-extensible",
      "options": [
        {
          "text": "You can mark an object non-extensible in 3 ways,\n\n      1",
          "is_correct": true
        },
        {
          "text": "The function call `functionOne` is not going to be part of scope chain and it has it's own execution context with the enclosed variable environment",
          "is_correct": false
        },
        {
          "text": "It returns undefined for non-strict mode and returns Error for strict mode",
          "is_correct": false
        },
        {
          "text": "Regular Expressions provide a group of patterns in order to match characters",
          "is_correct": false
        }
      ],
      "explanation": "You can mark an object non-extensible in 3 ways,\n\n      1. `Object.preventExtensions`\n      2. `Object.seal`\n      3. `Object.freeze`\n\n      ```javascript\n      var newObject = {};\n\n      Object.preventExtensions(newObject); // Prevent objects are non-extensible\n      Object.isExtensible(newObject); // false\n\n      var sealedObject = Object.seal({}); // Sealed objects are non-extensible\n      Object.isExtensible(sealedObject); // false\n\n      var frozenObject = Object.freeze({}); // Frozen objects are non-extensible\n      Object.isExtensible(frozenObject); // false\n      ```\n\n265."
    },
    {
      "text": "How do you define multiple properties on an object",
      "options": [
        {
          "text": "An iterator is an object which defines a sequence and a return value upon its termination",
          "is_correct": false
        },
        {
          "text": "You can mark an object non-extensible in 3 ways,\n\n      1",
          "is_correct": false
        },
        {
          "text": "defineProperties()` method is used to define new or modify existing properties directly on an object and returning the object",
          "is_correct": true
        },
        {
          "text": "Below are the list of methods available on `WeakSet`,\n\n      1",
          "is_correct": false
        }
      ],
      "explanation": "The `Object.defineProperties()` method is used to define new or modify existing properties directly on an object and returning the object. Let's define multiple properties on an empty object,\n\n      ```javascript\n      const newObject = {};\n\n      Object.defineProperties(newObject, {\n        newProperty1: {\n          value: \"John\",\n          writable: true,\n        },\n        newProperty2: {},\n      });\n      ```\n\n266."
    },
    {
      "text": "How do you perform form validation without javascript",
      "options": [
        {
          "text": "Module pattern is a designed pattern used to wrap a set of variables and functions together in a single scope returned as an object",
          "is_correct": false
        },
        {
          "text": "The Window object implements the `WindowLocalStorage` and `WindowSessionStorage` objects which has `localStorage`(window",
          "is_correct": false
        },
        {
          "text": "The constructor method is a special method for creating and initializing an object created within a class",
          "is_correct": false
        },
        {
          "text": "You can perform HTML form validation automatically without using javascript",
          "is_correct": true
        }
      ],
      "explanation": "You can perform HTML form validation automatically without using javascript. The validation enabled by applying the `required` attribute to prevent form submission when the input is empty.\n\n      ```html\n\n      ```\n\n      **Note:** Automatic form validation does not work in Internet Explorer 9 or earlier.\n\n275."
    },
    {
      "text": "Are enums available in javascript",
      "options": [
        {
          "text": "JavaScript is a loosely typed or a dynamic language because variables in JavaScript are not directly associated with any particular value type, and any variable can be assigned/reassigned with values of all types",
          "is_correct": false
        },
        {
          "text": "No, javascript does not natively support enums",
          "is_correct": true
        },
        {
          "text": "If you leave out the right-hand side assignment for the destructuring object, the function will look for at least one argument to be supplied when invoked",
          "is_correct": false
        },
        {
          "text": "Yes, you can apply chaining on conditional operators similar to **`if … else if … else if … else`** chain",
          "is_correct": false
        }
      ],
      "explanation": "No, javascript does not natively support enums. But there are different kinds of solutions to simulate them even though they may not provide exact equivalents. For example, you can use freeze or seal on object,\n\n      ```javascript\n      var DaysEnum = Object.freeze({\"monday\":1, \"tuesday\":2, \"wednesday\":3, ...})\n      ```\n\n280."
    },
    {
      "text": "How do you get property descriptors of an object",
      "options": [
        {
          "text": "When receiving the data from a web server, the data is always in a string format",
          "is_correct": false
        },
        {
          "text": "You can use the `Object",
          "is_correct": true
        },
        {
          "text": "Eventhough the above function returns the same result for the same arguments(input) that are passed in the function, the `console",
          "is_correct": false
        },
        {
          "text": "The javascript parser will automatically add a semicolon while parsing the source code",
          "is_correct": false
        }
      ],
      "explanation": "You can use the `Object.getOwnPropertyDescriptors()` method which returns all own property descriptors of a given object. The example usage of this method is below,\n\n      ```javascript\n      const newObject = {\n        a: 1,\n        b: 2,\n        c: 3,\n      };\n      const descriptorsObject = Object.getOwnPropertyDescriptors(newObject);\n      console.log(descriptorsObject.a.writable); //true\n      console.log(descriptorsObject.a.configurable); //true\n      console.log(descriptorsObject.a.enumerable); //true\n      console.log(descriptorsObject.a.value); // 1\n      ```\n\n283."
    },
    {
      "text": "What are the attributes provided by a property descriptor",
      "options": [
        {
          "text": "A property descriptor is a record which has the following attributes\n\n      1",
          "is_correct": true
        },
        {
          "text": "isExtensible()` method is used to determine if an object is extendable or not",
          "is_correct": false
        },
        {
          "text": "defineProperty()` static method is used to define a new property directly on an object, or modify an existing property on an object, and returns the object",
          "is_correct": false
        },
        {
          "text": "The Error constructor creates an error object and the instances of error objects are thrown when runtime errors occur",
          "is_correct": false
        }
      ],
      "explanation": "A property descriptor is a record which has the following attributes\n\n      1. `value`: The value associated with the property\n      2. `writable`: Determines whether the value associated with the property can be changed or not\n      3. `configurable`: Returns true if the type of this property descriptor can be changed and if the property can be deleted from the corresponding object.\n      4. `enumerable`: Determines whether the property appears during enumeration of the properties on the corresponding object or not.\n      5. `set`: A function which serves as a setter for the property\n      6. `get`: A function which serves as a getter for the property\n\n284."
    },
    {
      "text": "How do you extend classes",
      "options": [
        {
          "text": "This is also known as Document Object Model (DOM) |\n    | By default window object is available implicitly in the page                  | You can access it via window",
          "is_correct": false
        },
        {
          "text": "There are different solutions based on ECMAScript versions\n\n      1",
          "is_correct": false
        },
        {
          "text": "The `extends` keyword is used in class declarations/expressions to create a class which is a child of another class",
          "is_correct": true
        },
        {
          "text": "IIFE(Immediately Invoked Function Expression) is just like any other function expression which won't be hoisted",
          "is_correct": false
        }
      ],
      "explanation": "The `extends` keyword is used in class declarations/expressions to create a class which is a child of another class. It can be used to subclass custom classes as well as built-in objects. The syntax would be as below,\n\n      ```javascript\n      class ChildClass extends ParentClass { ... }\n      ```\n\n      Let's take an example of Square subclass from Polygon parent class,\n\n      ```javascript\n      class Square extends Rectangle {\n        constructor(length) {\n          super(length, length);\n          this.name = \"Square\";\n        }\n\n        get area() {\n          return this.width * this.height;\n        }\n\n        set area(value) {\n          this.area = value;\n        }\n      }\n      ```\n\n285."
    },
    {
      "text": "How to get the value from get parameters",
      "options": [
        {
          "text": "You can check whether a key exists in an object or not using three approaches,\n\n      1",
          "is_correct": false
        },
        {
          "text": "The `new URL()` object accepts the url string and `searchParams` property of this object can be used to access the get parameters",
          "is_correct": true
        },
        {
          "text": "Module pattern is a designed pattern used to wrap a set of variables and functions together in a single scope returned as an object",
          "is_correct": false
        },
        {
          "text": "The type of operator on new Number always returns object",
          "is_correct": false
        }
      ],
      "explanation": "The `new URL()` object accepts the url string and `searchParams` property of this object can be used to access the get parameters.\n\n      ```javascript\n      let urlString = \"http://www.some-domain.com/about.html?x=1&y=2&z=3\"; //window.location.href\n      let url = new URL(urlString);\n      let parameterZ = url.searchParams.get(\"z\");\n      console.log(parameterZ); // 3\n      ```\n\n289."
    },
    {
      "text": "How do you print numbers with commas as thousand separators",
      "options": [
        {
          "text": "You can use the `Number",
          "is_correct": true
        },
        {
          "text": "Yes, You can use the `Object",
          "is_correct": false
        },
        {
          "text": "In JavaScript, primitive types include boolean, string, number, BigInt, null, Symbol and undefined",
          "is_correct": false
        },
        {
          "text": "The combination of `Window",
          "is_correct": false
        }
      ],
      "explanation": "You can use the `Number.prototype.toLocaleString()` method which returns a string with a language-sensitive representation such as thousand separator, currency etc. of this number.\n\n      ```javascript\n      function convertToThousandFormat(x) {\n        return x.toLocaleString(); // 12,345.679\n      }\n\n      console.log(convertToThousandFormat(12345.6789));\n      ```\n\n290."
    },
    {
      "text": "What is the difference between java and javascript",
      "options": [
        {
          "text": "No, you cannot use the reserved words as variables, labels, object or function names",
          "is_correct": false
        },
        {
          "text": "Arrow functions do not have an `arguments, super, this, or new",
          "is_correct": false
        },
        {
          "text": "Both are totally unrelated programming languages and no relation between them",
          "is_correct": true
        },
        {
          "text": "An expression in javascript that can be replaced by its value without affecting the behaviour of the program is called referential transparency",
          "is_correct": false
        }
      ],
      "explanation": "Both are totally unrelated programming languages and no relation between them. Java is statically typed, compiled, runs on its own VM. Whereas Javascript is dynamically typed, interpreted, and runs in a browser and nodejs environments. Let's see the major differences in a tabular format,\n      | Feature | Java | JavaScript |\n      |---- | ---- | -----\n      | Typed | It's a strongly typed language | It's a dynamic typed language |\n      | Paradigm | Object oriented programming | Prototype based programming |\n      | Scoping | Block scoped | Function-scoped, block scoped since ES6 |\n      | Concurrency | Thread based | event based |\n\n291."
    },
    {
      "text": "Does JavaScript support namespaces",
      "options": [
        {
          "text": "You can mark an object non-extensible in 3 ways,\n\n      1",
          "is_correct": false
        },
        {
          "text": "You can use `new Date()` to generate a new Date object containing the current date and time",
          "is_correct": false
        },
        {
          "text": "JavaScript doesn’t support namespaces by default",
          "is_correct": true
        },
        {
          "text": "The javascript parser will automatically add a semicolon while parsing the source code",
          "is_correct": false
        }
      ],
      "explanation": "JavaScript doesn’t support namespaces by default. So if you create any element (function, method, object, variable) then it becomes global and pollutes the global namespace. Let's take an example of defining two functions without any namespace,\n\n      ```javascript\n      function func1() {\n        console.log(\"This is a first definition\");\n      }\n      function func1() {\n        console.log(\"This is a second definition\");\n      }\n      func1(); // This is a second definition\n      ```\n\n      It always calls the second function definition. In this case, namespaces will solve the name collision problem.\n\n292."
    },
    {
      "text": "How do you declare a namespace",
      "options": [
        {
          "text": "isExtensible()` method is used to determine if an object is extendable or not",
          "is_correct": false
        },
        {
          "text": "Even though JavaScript lacks namespaces, we can use Objects, an IIFE (Immediately Invoked Function Expression) or `let`/`const` to create namespaces",
          "is_correct": true
        },
        {
          "text": "ES6 provides method definitions and property shorthands for objects",
          "is_correct": false
        },
        {
          "text": "The javascript parser will automatically add a semicolon while parsing the source code",
          "is_correct": false
        }
      ],
      "explanation": "Even though JavaScript lacks namespaces, we can use Objects, an IIFE (Immediately Invoked Function Expression) or `let`/`const` to create namespaces.\n\n      1. **Using Object Literal Notation:** Let's wrap variables and functions inside an Object literal which acts as a namespace. After that you can access them using object notation\n\n         ```javascript\n         var namespaceOne = {\n             function func1() {\n                 console.log(\"This is a first definition\");\n             }\n         }\n         var namespaceTwo = {\n               function func1() {\n                   console.log(\"This is a second definition\");\n               }\n           }\n         namespaceOne.func1(); // This is a first definition\n         namespaceTwo.func1(); // This is a second definition\n         ```\n\n      2. **Using IIFE (Immediately invoked function expression):** The outer pair of parentheses of IIFE creates a local scope for all the code inside of it and makes the anonymous function a function expression. Due to that, you can create the same function in two different function expressions to act as a namespace.\n\n         ```javascript\n         (function () {\n           function fun1() {\n             console.log(\"This is a first definition\");\n           }\n           fun1();\n         })();\n\n         (function () {\n           function fun1() {\n             console.log(\"This is a second definition\");\n           }\n           fun1();\n         })();\n         ```\n\n      3. **Using a block and a let/const declaration:** In ECMAScript 6, you can simply use a block and a let declaration to restrict the scope of a variable to a block.\n\n         ```javascript\n         {\n           let myFunction = function fun1() {\n             console.log(\"This is a first definition\");\n           };\n           myFunction();\n         }\n         //myFunction(): ReferenceError: myFunction is not defined.\n\n         {\n           let myFunction = function fun1() {\n             console.log(\"This is a second definition\");\n           };\n           myFunction();\n         }\n         //myFunction(): ReferenceError: myFunction is not defined.\n         ```\n\n293."
    },
    {
      "text": "How do you get the timezone offset of a date object",
      "options": [
        {
          "text": "Yes, JavaScript is a case sensitive language",
          "is_correct": false
        },
        {
          "text": "JavaScript does not have built-in support for mixins as a formal language feature",
          "is_correct": false
        },
        {
          "text": "You can use the `getTimezoneOffset` method of the date object",
          "is_correct": true
        },
        {
          "text": "Both are totally unrelated programming languages and no relation between them",
          "is_correct": false
        }
      ],
      "explanation": "You can use the `getTimezoneOffset` method of the date object. This method returns the time zone difference, in minutes, from current locale (host system settings) to UTC\n\n      ```javascript\n      var offset = new Date().getTimezoneOffset();\n      console.log(offset); // -480\n      ```\n\n295."
    },
    {
      "text": "How do you load CSS and JS files dynamically",
      "options": [
        {
          "text": "Web storage is an API that provides a mechanism by which browsers can store key/value pairs locally within the user's browser, in a much more intuitive fashion than using cookies",
          "is_correct": false
        },
        {
          "text": "You can create both link and script elements in the DOM and append them as child to head tag",
          "is_correct": true
        },
        {
          "text": "WebWorkers don't have access to below javascript objects since they are defined in an external files\n\n    1",
          "is_correct": false
        },
        {
          "text": "dir()` is used to display an interactive list of the properties of the specified JavaScript object as JSON",
          "is_correct": false
        }
      ],
      "explanation": "You can create both link and script elements in the DOM and append them as child to head tag. Let's create a function to add script and style resources as below,\n\n      ```javascript\n      function loadAssets(filename, filetype) {\n        if (filetype == \"css\") {\n          // External CSS file\n          var fileReference = document.createElement(\"link\");\n          fileReference.setAttribute(\"rel\", \"stylesheet\");\n          fileReference.setAttribute(\"type\", \"text/css\");\n          fileReference.setAttribute(\"href\", filename);\n        } else if (filetype == \"js\") {\n          // External JavaScript file\n          var fileReference = document.createElement(\"script\");\n          fileReference.setAttribute(\"type\", \"text/javascript\");\n          fileReference.setAttribute(\"src\", filename);\n        }\n        if (typeof fileReference != \"undefined\")\n          document.getElementsByTagName(\"head\")[0].appendChild(fileReference);\n      }\n      ```\n\n296."
    },
    {
      "text": "What are the different methods to find HTML elements in DOM",
      "options": [
        {
          "text": "The javascript parser will automatically add a semicolon while parsing the source code",
          "is_correct": false
        },
        {
          "text": "If you want to access any element in an HTML page, you need to start with accessing the document object",
          "is_correct": true
        },
        {
          "text": "An expression in javascript that can be replaced by its value without affecting the behaviour of the program is called referential transparency",
          "is_correct": false
        },
        {
          "text": "The functions which are created with `Function constructor` do not create closures to their creation contexts but they are always created in the global scope",
          "is_correct": false
        }
      ],
      "explanation": "If you want to access any element in an HTML page, you need to start with accessing the document object. Later you can use any of the below methods to find the HTML element,\n\n      1. `document.getElementById(id)`: It finds an element by Id\n      2. `document.getElementsByTagName(name)`: It finds an element by tag name (returns an node list)\n      3. `document.getElementsByClassName(name)`: It finds an element by class name (returns an node list)\n      4. `document.querySelector(cssSelector)`: It finds an element by css selector\n      5. `document.querySelectorAll(cssSelector)`: It finds all elements by css selector (returns a node list)\n\n297."
    },
    {
      "text": "Why do we call javascript as dynamic language",
      "options": [
        {
          "text": "The type of operator on new Number always returns object",
          "is_correct": false
        },
        {
          "text": "JavaScript is a loosely typed or a dynamic language because variables in JavaScript are not directly associated with any particular value type, and any variable can be assigned/reassigned with values of all types",
          "is_correct": true
        },
        {
          "text": "The object property follows below rules,\n\n1",
          "is_correct": false
        },
        {
          "text": "Both are totally unrelated programming languages and no relation between them",
          "is_correct": false
        }
      ],
      "explanation": "JavaScript is a loosely typed or a dynamic language because variables in JavaScript are not directly associated with any particular value type, and any variable can be assigned/reassigned with values of all types.\n\n      ```javascript\n      let age = 50; // age is a number now\n      age = \"old\"; // age is a string now\n      age = true; // age is a boolean\n      ```\n\n300."
    },
    {
      "text": "What are enhanced object literals",
      "options": [
        {
          "text": "Yes, You can use the `Object",
          "is_correct": false
        },
        {
          "text": "Generators are not constructible type",
          "is_correct": false
        },
        {
          "text": "JavaScript was created by Brendan Eich in 1995 during his time at Netscape Communications",
          "is_correct": false
        },
        {
          "text": "Object literals make it easy to quickly create objects with properties inside the curly braces",
          "is_correct": true
        }
      ],
      "explanation": "Object literals make it easy to quickly create objects with properties inside the curly braces. For example, it provides shorter syntax for common object property definition as below.\n\n      ```javascript\n      //ES6\n      var x = 10,\n        y = 20;\n      obj = { x, y };\n      console.log(obj); // {x: 10, y:20}\n      //ES5\n      var x = 10,\n        y = 20;\n      obj = { x: x, y: y };\n      console.log(obj); // {x: 10, y:20}\n      ```\n\n319."
    },
    {
      "text": "What paradigm is Javascript",
      "options": [
        {
          "text": "You can use the `import",
          "is_correct": false
        },
        {
          "text": "JavaScript is a multi-paradigm language, supporting imperative/procedural programming, Object-Oriented Programming and functional programming",
          "is_correct": true
        },
        {
          "text": "There are two ways to copy an object,\n\n      **Shallow Copy:**\n      Shallow copy is a bitwise copy of an object",
          "is_correct": false
        },
        {
          "text": "Eventhough both variables `a` and `b` refer a number value, the first declaration is based on constructor function and the type of the variable is going to be `object` type",
          "is_correct": false
        }
      ],
      "explanation": "JavaScript is a multi-paradigm language, supporting imperative/procedural programming, Object-Oriented Programming and functional programming. JavaScript supports Object-Oriented Programming with prototypical inheritance.\n\n332."
    },
    {
      "text": "How do you get the status of a checkbox",
      "options": [
        {
          "text": "V8 engine uses the below optimization techniques",
          "is_correct": false
        },
        {
          "text": "Below are the list of placeholders available from console object,\n\n      1",
          "is_correct": false
        },
        {
          "text": "An expression in javascript that can be replaced by its value without affecting the behaviour of the program is called referential transparency",
          "is_correct": false
        },
        {
          "text": "You can apply the `checked` property on the selected checkbox in the DOM",
          "is_correct": true
        }
      ],
      "explanation": "You can apply the `checked` property on the selected checkbox in the DOM. If the value is `true` it means the checkbox is checked, otherwise it is unchecked. For example, the below HTML checkbox element can be access using javascript as below:\n\n      ```html\n      \n      Agree the conditions\n      \n      ```\n\n      ```javascript\n      console.log(document.getElementById(‘checkboxname’).checked); // true or false\n      ```\n\n335."
    },
    {
      "text": "How do you convert character to ASCII code",
      "options": [
        {
          "text": "The value null represents the intentional absence of any object value",
          "is_correct": false
        },
        {
          "text": "Arrow functions do not have an `arguments, super, this, or new",
          "is_correct": false
        },
        {
          "text": "You can use the `String",
          "is_correct": true
        },
        {
          "text": "`Native objects` are objects that are part of the JavaScript language defined by the ECMAScript specification",
          "is_correct": false
        }
      ],
      "explanation": "You can use the `String.prototype.charCodeAt()` method to convert string characters to ASCII numbers. For example, let's find ASCII code for the first letter of 'ABC' string,\n\n      ```javascript\n      \"ABC\".charCodeAt(0); // returns 65\n      ```\n\n      Whereas `String.fromCharCode()` method converts numbers to equal ASCII characters.\n\n      ```javascript\n      String.fromCharCode(65, 66, 67); // returns 'ABC'\n      ```\n\n337."
    },
    {
      "text": "What is the purpose of Error object",
      "options": [
        {
          "text": "There are different solutions based on ECMAScript versions\n\n      1",
          "is_correct": false
        },
        {
          "text": "There are 3 possible ways for accessing the property of an object",
          "is_correct": false
        },
        {
          "text": "The Error constructor creates an error object and the instances of error objects are thrown when runtime errors occur",
          "is_correct": true
        },
        {
          "text": "Even though JavaScript lacks namespaces, we can use Objects, an IIFE (Immediately Invoked Function Expression) or `let`/`const` to create namespaces",
          "is_correct": false
        }
      ],
      "explanation": "The Error constructor creates an error object and the instances of error objects are thrown when runtime errors occur. The Error object can also be used as a base object for user-defined exceptions. The syntax of error object would be as below,\n\n      ```javascript\n      new Error([message[, fileName[, lineNumber]]])\n      ```\n\n      You can throw user defined exceptions or errors using Error object in try...catch block as below,\n\n      ```javascript\n      try {\n        if (withdraw > balance)\n          throw new Error(\"Oops! You don't have enough balance\");\n      } catch (e) {\n        console.log(e.name + \": \" + e.message);\n      }\n      ```\n\n340."
    },
    {
      "text": "What is the purpose of EvalError object",
      "options": [
        {
          "text": "Browsers provide an XMLHttpRequest object which can be used to make synchronous HTTP requests from JavaScript",
          "is_correct": false
        },
        {
          "text": "The EvalError object indicates an error regarding the global `eval()` function",
          "is_correct": true
        },
        {
          "text": "Even though we used constant variables, the content of it is an object and the object's contents (e",
          "is_correct": false
        },
        {
          "text": "Module pattern is a designed pattern used to wrap a set of variables and functions together in a single scope returned as an object",
          "is_correct": false
        }
      ],
      "explanation": "The EvalError object indicates an error regarding the global `eval()` function. Even though this exception is not thrown by JavaScript anymore, the EvalError object remains for compatibility. The syntax of this expression would be as below,\n\n      ```javascript\n      new EvalError([message[, fileName[, lineNumber]]])\n      ```\n\n      You can throw EvalError with in try...catch block as below,\n\n      ```javascript\n      try {\n        throw new EvalError('Eval function error', 'someFile.js', 100);\n      } catch (e) {\n        console.log(e.message, e.name, e.fileName);              // \"Eval function error\", \"EvalError\", \"someFile.js\"\n      ```\n\n341."
    },
    {
      "text": "What are the list of cases error thrown from non-strict mode to strict mode",
      "options": [
        {
          "text": "When you apply 'use strict'; syntax, some of the below cases will throw a SyntaxError before executing the script\n\n      1",
          "is_correct": true
        },
        {
          "text": "You need to use date",
          "is_correct": false
        },
        {
          "text": "The execution context in JavaScript is a data structure that stores the information necessary for executing a piece of code",
          "is_correct": false
        },
        {
          "text": "Regular Expressions provide a group of patterns in order to match characters",
          "is_correct": false
        }
      ],
      "explanation": "When you apply 'use strict'; syntax, some of the below cases will throw a SyntaxError before executing the script\n\n      1. When you use Octal syntax\n\n      ```javascript\n      var n = 022;\n      ```\n\n      2. Using `with` statement\n      3. When you use delete operator on a variable name\n      4. Using eval or arguments as variable or function argument name\n      5. When you use newly reserved keywords\n      6. When you declare a function in a block and access it from outside of the block\n\n      ```javascript\n      if (someCondition) {\n        function f() {}\n      }\n      f(); // ReferenceError: f is not defined\n      ```\n\n      Hence, the errors from above cases are helpful to avoid errors in development/production environments.\n\n342."
    },
    {
      "text": "Do all objects have prototypes",
      "options": [
        {
          "text": "The `uneval()` is an builtin function which is used to create a string representation of the source code of an Object",
          "is_correct": false
        },
        {
          "text": "You can use the `Number",
          "is_correct": false
        },
        {
          "text": "All objects have prototypes except two exceptions:\n      *  **Object",
          "is_correct": true
        },
        {
          "text": "In order to be consistent with functions like `String",
          "is_correct": false
        }
      ],
      "explanation": "No. All objects have prototypes except two exceptions:\n      *  **Object.prototype** itself — This is the base object in the prototype chain, and **its prototype is** `null`.\n      *   **Objects created with** `**Object.create(null)**` — These are deliberately created with **no prototype**, so they don’t inherit from `Object.prototype`.\n\n      All other standard objects do have a prototype.  \n\n343."
    },
    {
      "text": "What is the difference between Shallow and Deep copy",
      "options": [
        {
          "text": "Code snippet:**\n\n      **Output:**\n\n      The output is 40 and NaN",
          "is_correct": false
        },
        {
          "text": "There are two ways to copy an object,\n\n      **Shallow Copy:**\n      Shallow copy is a bitwise copy of an object",
          "is_correct": true
        },
        {
          "text": "Generators are not constructible type",
          "is_correct": false
        },
        {
          "text": "You can use innerWidth, innerHeight, clientWidth, clientHeight properties of windows, document element and document body objects to find the size of a window",
          "is_correct": false
        }
      ],
      "explanation": "There are two ways to copy an object,\n\n      **Shallow Copy:**\n      Shallow copy is a bitwise copy of an object. A new object is created that has an exact copy of the values in the original object. If any of the fields of the object are references to other objects, just the reference addresses are copied i.e., only the memory address is copied.\n\n      **Example**\n\n      ```javascript\n      var empDetails = {\n        name: \"John\",\n        age: 25,\n        expertise: \"Software Developer\",\n      };\n      ```\n\n      to create a duplicate\n\n      ```javascript\n      var empDetailsShallowCopy = empDetails; //Shallow copying!\n      ```\n\n      if we change some property value in the duplicate one like this:\n\n      ```javascript\n      empDetailsShallowCopy.name = \"Johnson\";\n      ```\n\n      The above statement will also change the name of `empDetails`, since we have a shallow copy. That means we're losing the original data as well.\n\n      **Deep copy:**\n      A deep copy copies all fields, and makes copies of dynamically allocated memory pointed to by the fields. A deep copy occurs when an object is copied along with the objects to which it refers.\n\n      **Example**\n\n      ```javascript\n      var empDetails = {\n        name: \"John\",\n        age: 25,\n        expertise: \"Software Developer\",\n      };\n      ```\n\n      Create a deep copy by using the properties from the original object into new variable\n\n      ```javascript\n      var empDetailsDeepCopy = {\n        name: empDetails.name,\n        age: empDetails.age,\n        expertise: empDetails.expertise,\n      };\n      ```\n\n      Now if you change `empDetailsDeepCopy.name`, it will only affect `empDetailsDeepCopy` & not `empDetails`\n\n347."
    },
    {
      "text": "How do you create specific number of copies of a string",
      "options": [
        {
          "text": "If you leave out the right-hand side assignment for the destructuring object, the function will look for at least one argument to be supplied when invoked",
          "is_correct": false
        },
        {
          "text": "Arrow functions do not have an `arguments, super, this, or new",
          "is_correct": false
        },
        {
          "text": "A `WeakSet` is used to store a collection of weakly(weak references) held objects",
          "is_correct": false
        },
        {
          "text": "The `repeat()` method is used to construct and return a new string which contains the specified number of copies of the string on which it was called, concatenated together",
          "is_correct": true
        }
      ],
      "explanation": "The `repeat()` method is used to construct and return a new string which contains the specified number of copies of the string on which it was called, concatenated together. Remember that this method has been added to the ECMAScript 2015 specification.\n      Let's take an example of Hello string to repeat it 4 times,\n\n      ```javascript\n      \"Hello\".repeat(4); // 'HelloHelloHelloHello'\n      ```\n\n348."
    },
    {
      "text": "How do you trim a string at the beginning or ending",
      "options": [
        {
          "text": "The **`freeze()`** method is used to freeze an object",
          "is_correct": false
        },
        {
          "text": "target` pseudo-property to detect whether a function was called as a constructor(using the new operator) or as a regular function call",
          "is_correct": false
        },
        {
          "text": "The \"constructor\" in a class is a special method and it should be defined only once in a class",
          "is_correct": false
        },
        {
          "text": "The `trim` method of string prototype is used to trim on both sides of a string",
          "is_correct": true
        }
      ],
      "explanation": "The `trim` method of string prototype is used to trim on both sides of a string. But if you want to trim especially at the beginning or ending of the string then you can use `trimStart/trimLeft` and `trimEnd/trimRight` methods. Let's see an example of these methods on a greeting message,\n\n      ```javascript\n      var greeting = \"   Hello, Goodmorning!   \";\n\n      console.log(greeting); // \"   Hello, Goodmorning!   \"\n      console.log(greeting.trimStart()); // \"Hello, Goodmorning!   \"\n      console.log(greeting.trimLeft()); // \"Hello, Goodmorning!   \"\n\n      console.log(greeting.trimEnd()); // \"   Hello, Goodmorning!\"\n      console.log(greeting.trimRight()); // \"   Hello, Goodmorning!\"\n      ```\n\n350."
    },
    {
      "text": "Does javascript uses mixins",
      "options": [
        {
          "text": "JavaScript does not have built-in support for mixins as a formal language feature",
          "is_correct": true
        },
        {
          "text": "Yes, we can define properties for functions because functions are also objects",
          "is_correct": false
        },
        {
          "text": "The global execution context is the default or first execution context that is created by the JavaScript engine before any code is executed(i",
          "is_correct": false
        },
        {
          "text": "The value null represents the intentional absence of any object value",
          "is_correct": false
        }
      ],
      "explanation": "JavaScript does not have built-in support for mixins as a formal language feature. However, developers commonly implement mixins using various patterns to enable code reuse and composition.\n\n      A mixin is a way to add reusable functionality from one or more objects into a class or another object, without using classical inheritance. It promotes object composition by combining behaviors or properties from different sources into a single destination.\n\n352."
    },
    {
      "text": "What is the output of below function calls",
      "options": [
        {
          "text": "Code snippet:**\n\n      **Output:**\n\n      The output is 40 and NaN",
          "is_correct": true
        },
        {
          "text": "A decorator is an expression that evaluates to a function and that takes the target, name, and decorator descriptor as arguments",
          "is_correct": false
        },
        {
          "text": "There are different solutions based on ECMAScript versions\n\n      1",
          "is_correct": false
        },
        {
          "text": "A _repaint_ occurs when changes are made which affect the visibility of an element, but not its layout",
          "is_correct": false
        }
      ],
      "explanation": "**Code snippet:**\n\n      ```javascript\n      const circle = {\n        radius: 20,\n        diameter() {\n          return this.radius * 2;\n        },\n        perimeter: () => 2 * Math.PI * this.radius,\n      };\n      ```\n\n      ```javascript\n      console.log(circle.diameter());\n      console.log(circle.perimeter());\n      ```\n\n      **Output:**\n\n      The output is 40 and NaN. Remember that diameter is a regular function, whereas the value of perimeter is an arrow function. The `this` keyword of a regular function(i.e, diameter) refers to the surrounding scope which is a class(i.e, Shape object). Whereas this keyword of perimeter function refers to the surrounding scope which is a window object. Since there is no radius property on window objects it returns an undefined value and the multiple of number value returns NaN value.\n\n357."
    },
    {
      "text": "What is the difference between reflow and repaint",
      "options": [
        {
          "text": "An expression in javascript that can be replaced by its value without affecting the behaviour of the program is called referential transparency",
          "is_correct": false
        },
        {
          "text": "You can use the `super` keyword to call the constructor of a parent class",
          "is_correct": false
        },
        {
          "text": "A _repaint_ occurs when changes are made which affect the visibility of an element, but not its layout",
          "is_correct": true
        },
        {
          "text": "Yes, we can define properties for functions because functions are also objects",
          "is_correct": false
        }
      ],
      "explanation": "A _repaint_ occurs when changes are made which affect the visibility of an element, but not its layout. Examples of this include outline, visibility, or background color. A _reflow_ involves changes that affect the layout of a portion of the page (or the whole page). Resizing the browser window, changing the font, content changing (such as user typing text), using JavaScript methods involving computed styles, adding or removing elements from the DOM, and changing an element's classes are a few of the things that can trigger reflow. Reflow of an element causes the subsequent reflow of all child and ancestor elements as well as any elements following it in the DOM.\n\n359."
    },
    {
      "text": "What is destructuring aliases",
      "options": [
        {
          "text": "An object initializer is an expression that describes the initialization of an Object",
          "is_correct": false
        },
        {
          "text": "In modern JavaScript applications, singletons are commonly implemented using ES6 modules for their built-in caching behavior, or closures for encapsulated state management",
          "is_correct": false
        },
        {
          "text": "Sometimes you would like to have a destructured variable with a different name than the property name",
          "is_correct": true
        },
        {
          "text": "The `this` keyword in JavaScript refers to **the object that is executing the current function**",
          "is_correct": false
        }
      ],
      "explanation": "Sometimes you would like to have a destructured variable with a different name than the property name. In that case, you'll use a `: newName` to specify a name for the variable. This process is called destructuring aliases.\n\n      ```javascript\n      const obj = { x: 1 };\n      // Grabs obj.x as as { otherName }\n      const { x: otherName } = obj;\n      ```\n\n366."
    },
    {
      "text": "What are the placeholders from console object",
      "options": [
        {
          "text": "Below are the list of placeholders available from console object,\n\n      1",
          "is_correct": true
        },
        {
          "text": "An iterator is an object which defines a sequence and a return value upon its termination",
          "is_correct": false
        },
        {
          "text": "Due to hositing feature, the variables declared with `var` will have `undefined` value in the creation phase so the outer variable `currentCity` will get same `undefined` value",
          "is_correct": false
        },
        {
          "text": "There are two ways to copy an object,\n\n      **Shallow Copy:**\n      Shallow copy is a bitwise copy of an object",
          "is_correct": false
        }
      ],
      "explanation": "Below are the list of placeholders available from console object,\n\n      1. %o — It takes an object,\n      2. %s — It takes a string,\n      3. %d — It is used for a decimal or integer\n         These placeholders can be represented in the console.log as below\n\n      ```javascript\n      const user = { name: \"John\", id: 1, city: \"Delhi\" };\n      console.log(\n        \"Hello %s, your details %o are available in the object form\",\n        \"John\",\n        user\n      ); // Hello John, your details {name: \"John\", id: 1, city: \"Delhi\"} are available in object\n      ```\n\n372."
    },
    {
      "text": "Is it possible to add CSS to console messages",
      "options": [
        {
          "text": "If an object is frozen using the `Object",
          "is_correct": false
        },
        {
          "text": "The custom bind function needs to be created on Function prototype inorder to use it as other builtin functions",
          "is_correct": false
        },
        {
          "text": "Yes, you can apply CSS styles to console messages similar to html text on the web page",
          "is_correct": true
        },
        {
          "text": "JavaScript provided a trim method on string types to trim any whitespaces present at the beginning or ending of the string",
          "is_correct": false
        }
      ],
      "explanation": "Yes, you can apply CSS styles to console messages similar to html text on the web page.\n\n      ```javascript\n      console.log(\n        \"%c The text has blue color, with large font and red background\",\n        \"color: blue; font-size: x-large; background: red\"\n      );\n      ```\n\n      The text will be displayed as below,\n      ![Screenshot](images/console-css.png)\n\n      **Note:** All CSS styles can be applied to console messages.\n\n373."
    },
    {
      "text": "What is the purpose of dir method of console object",
      "options": [
        {
          "text": "Eventhough both variables `a` and `b` refer a number value, the first declaration is based on constructor function and the type of the variable is going to be `object` type",
          "is_correct": false
        },
        {
          "text": "dir()` is used to display an interactive list of the properties of the specified JavaScript object as JSON",
          "is_correct": true
        },
        {
          "text": "TypeScript is a typed superset of JavaScript created by Microsoft that adds optional types, classes\n      and many other features, and compiles to plain JavaScript",
          "is_correct": false
        },
        {
          "text": "In ES6, Javascript classes are primarily syntactic sugar over JavaScript’s existing prototype-based inheritance",
          "is_correct": false
        }
      ],
      "explanation": "The `console.dir()` is used to display an interactive list of the properties of the specified JavaScript object as JSON.\n\n      ```javascript\n      const user = { name: \"John\", id: 1, city: \"Delhi\" };\n      console.dir(user);\n      ```\n\n      The user object displayed in JSON representation\n      ![Screenshot](images/console-dir.png)\n\n374."
    },
    {
      "text": "What are wrapper objects",
      "options": [
        {
          "text": "Primitive Values like string,number and boolean don't have properties and methods but they are temporarily converted or coerced to an object(Wrapper object) when you try to perform actions on them",
          "is_correct": true
        },
        {
          "text": "Yes, we can define properties for functions because functions are also objects",
          "is_correct": false
        },
        {
          "text": "Eventhough both variables `a` and `b` refer a number value, the first declaration is based on constructor function and the type of the variable is going to be `object` type",
          "is_correct": false
        },
        {
          "text": "If the function argument is set implicitly(not passing argument) or explicitly to undefined, the value of the argument is the default parameter",
          "is_correct": false
        }
      ],
      "explanation": "Primitive Values like string,number and boolean don't have properties and methods but they are temporarily converted or coerced to an object(Wrapper object) when you try to perform actions on them. For example, if you apply toUpperCase() method on a primitive string value, it does not throw an error but returns uppercase of the string.\n\n     ```javascript\n     let name = \"john\";\n\n     console.log(name.toUpperCase()); // Behind the scenes treated as console.log(new String(name).toUpperCase());\n     ```\n\n     i.e, Every primitive except null and undefined have Wrapper Objects and the list of wrapper objects are String,Number,Boolean,Symbol and BigInt.\n\n384."
    },
    {
      "text": "How do you use javascript libraries in typescript file",
      "options": [
        {
          "text": "It is known that not all JavaScript libraries or frameworks have TypeScript declaration files",
          "is_correct": true
        },
        {
          "text": "Arrow functions do not have an `arguments, super, this, or new",
          "is_correct": false
        },
        {
          "text": "Inline caching is an optimization technique based on the observation that repeated calls to same function tends to occur on same type of objects",
          "is_correct": false
        },
        {
          "text": "You can apply the `checked` property on the selected checkbox in the DOM",
          "is_correct": false
        }
      ],
      "explanation": "It is known that not all JavaScript libraries or frameworks have TypeScript declaration files. But if you still want to use libraries or frameworks in your TypeScript files without getting compilation errors, the only solution is `declare` keyword along with a variable declaration. For example, let's imagine you have a library called `customLibrary` that doesn’t have a TypeScript declaration and have a namespace called `customLibrary` in the global namespace. You can use this library in typescript code as below,\n\n     ```javascript\n     declare var customLibrary;\n     ```\n\n     In the runtime, typescript will provide the type to the `customLibrary` variable as `any` type. The another alternative without using declare keyword is below\n\n     ```javascript\n     var customLibrary: any;\n     ```\n\n395."
    },
    {
      "text": "What is heap",
      "options": [
        {
          "text": "You can use innerWidth, innerHeight, clientWidth, clientHeight properties of windows, document element and document body objects to find the size of a window",
          "is_correct": false
        },
        {
          "text": "target` pseudo-property to detect whether a function was called as a constructor(using the new operator) or as a regular function call",
          "is_correct": false
        },
        {
          "text": "Heap(Or memory heap) is the memory location where objects are stored when we define variables",
          "is_correct": true
        },
        {
          "text": "In order to be consistent with functions like `String",
          "is_correct": false
        }
      ],
      "explanation": "Heap(Or memory heap) is the memory location where objects are stored when we define variables. i.e, This is the place where all the memory allocations and de-allocation take place. Both heap and call-stack are two containers of JS runtime.\n     Whenever runtime comes across variables and function declarations in the code it stores them in the Heap.\n\n     ![Screenshot](images/heap.png)\n\n397."
    },
    {
      "text": "How do you detect primitive or non primitive value type",
      "options": [
        {
          "text": "Web storage is more secure, and large amounts of data can be stored locally, without affecting website performance",
          "is_correct": false
        },
        {
          "text": "In JavaScript, primitive types include boolean, string, number, BigInt, null, Symbol and undefined",
          "is_correct": true
        },
        {
          "text": "You can use the `` tag to detect javascript disabled or not",
          "is_correct": false
        },
        {
          "text": "target` pseudo-property to detect whether a function was called as a constructor(using the new operator) or as a regular function call",
          "is_correct": false
        }
      ],
      "explanation": "In JavaScript, primitive types include boolean, string, number, BigInt, null, Symbol and undefined. Whereas non-primitive types include the Objects. But you can easily identify them with the below function,\n\n     ```javascript\n     var myPrimitive = 30;\n     var myNonPrimitive = {};\n     function isPrimitive(val) {\n       return Object(val) !== val;\n     }\n\n     isPrimitive(myPrimitive);\n     isPrimitive(myNonPrimitive);\n     ```\n\n     If the value is a primitive data type, the Object constructor creates a new wrapper object for the value. But If the value is a non-primitive data type (an object), the Object constructor will give the same object.\n\n401."
    },
    {
      "text": "What is the difference between Function constructor and function declaration",
      "options": [
        {
          "text": "Both have similar results unless you use classes",
          "is_correct": false
        },
        {
          "text": "The main difference is that references to objects in `Set` are strong while references to objects in `WeakSet` are weak",
          "is_correct": false
        },
        {
          "text": "You can perform HTML form validation automatically without using javascript",
          "is_correct": false
        },
        {
          "text": "The functions which are created with `Function constructor` do not create closures to their creation contexts but they are always created in the global scope",
          "is_correct": true
        }
      ],
      "explanation": "The functions which are created with `Function constructor` do not create closures to their creation contexts but they are always created in the global scope. i.e, the function can access its own local variables and global scope variables only. Whereas function declarations can access outer function variables(closures) too.\n\n     Let's see this difference with an example,\n\n     **Function Constructor:**\n\n     ```javascript\n     var a = 100;\n     function createFunction() {\n       var a = 200;\n       return new Function(\"return a;\");\n     }\n     console.log(createFunction()()); // 100\n     ```\n\n     **Function declaration:**\n\n     ```javascript\n     var a = 100;\n     function createFunction() {\n       var a = 200;\n       return function func() {\n         return a;\n       };\n     }\n     console.log(createFunction()()); // 200\n     ```\n\n406."
    },
    {
      "text": "What is the difference between function and class declarations",
      "options": [
        {
          "text": "The main difference between function declarations and class declarations is `hoisting`",
          "is_correct": true
        },
        {
          "text": "The `extends` keyword is used in class declarations/expressions to create a class which is a child of another class",
          "is_correct": false
        },
        {
          "text": "Both are totally unrelated programming languages and no relation between them",
          "is_correct": false
        },
        {
          "text": "You can use the `Object",
          "is_correct": false
        }
      ],
      "explanation": "The main difference between function declarations and class declarations is `hoisting`. The function declarations are hoisted but not class declarations.\n\n     **Classes:**\n\n     ```javascript\n     const user = new User(); // ReferenceError\n\n     class User {}\n     ```\n\n     **Constructor Function:**\n\n     ```javascript\n     const user = new User(); // No error\n\n     function User() {}\n     ```\n\n410."
    },
    {
      "text": "How do you make an object iterable in javascript",
      "options": [
        {
          "text": "By default, plain objects are not iterable",
          "is_correct": true
        },
        {
          "text": "The `new URL()` object accepts the url string and `searchParams` property of this object can be used to access the get parameters",
          "is_correct": false
        },
        {
          "text": "ECMAScript 5 introduced javascript object accessors or computed properties through getters and setters",
          "is_correct": false
        },
        {
          "text": "A `WeakSet` is used to store a collection of weakly(weak references) held objects",
          "is_correct": false
        }
      ],
      "explanation": "By default, plain objects are not iterable. But you can make the object iterable by defining a `Symbol.iterator` property on it.\n\n     Let's demonstrate this with an example,\n\n     ```javascript\n     const collection = {\n       one: 1,\n       two: 2,\n       three: 3,\n       [Symbol.iterator]() {\n         const values = Object.keys(this);\n         let i = 0;\n         return {\n           next: () => {\n             return {\n               value: this[values[i++]],\n               done: i > values.length,\n             };\n           },\n         };\n       },\n     };\n\n     const iterator = collection[Symbol.iterator]();\n\n     console.log(iterator.next()); // → {value: 1, done: false}\n     console.log(iterator.next()); // → {value: 2, done: false}\n     console.log(iterator.next()); // → {value: 3, done: false}\n     console.log(iterator.next()); // → {value: undefined, done: true}\n     ```\n\n     The above process can be simplified using a generator function,\n\n     ```javascript\n     const collection = {\n       one: 1,\n       two: 2,\n       three: 3,\n       [Symbol.iterator]: function* () {\n         for (let key in this) {\n           yield this[key];\n         }\n       },\n     };\n     const iterator = collection[Symbol.iterator]();\n     console.log(iterator.next()); // {value: 1, done: false}\n     console.log(iterator.next()); // {value: 2, done: false}\n     console.log(iterator.next()); // {value: 3, done: false}\n     console.log(iterator.next()); // {value: undefined, done: true}\n     ```\n\n414."
    },
    {
      "text": "What is a Proper Tail Call",
      "options": [
        {
          "text": "Scope is the accessibility of variables, functions, and objects in some particular part of your code during runtime",
          "is_correct": false
        },
        {
          "text": "First, we should know about tail call before talking about \"Proper Tail Call\"",
          "is_correct": true
        },
        {
          "text": "The Browser Object Model (BOM) allows JavaScript to \"talk to\" the browser",
          "is_correct": false
        },
        {
          "text": "Using constructors, `new",
          "is_correct": false
        }
      ],
      "explanation": "First, we should know about tail call before talking about \"Proper Tail Call\". A tail call is a subroutine or function call performed as the final action of a calling function. Whereas **Proper tail call(PTC)** is a technique where the program or code will not create additional stack frames for a recursion when the function call is a tail call.\n\n     For example, the below classic or head recursion of factorial function relies on stack for each step. Each step need to be processed upto `n * factorial(n - 1)`\n\n     ```javascript\n     function factorial(n) {\n       if (n === 0) {\n         return 1;\n       }\n       return n * factorial(n - 1);\n     }\n     console.log(factorial(5)); //120\n     ```\n\n     But if you use Tail recursion functions, they keep passing all the necessary data it needs down the recursion without relying on the stack.\n\n     ```javascript\n     function factorial(n, acc = 1) {\n       if (n === 0) {\n         return acc;\n       }\n       return factorial(n - 1, n * acc);\n     }\n     console.log(factorial(5)); //120\n     ```\n\n     The above pattern returns the same output as the first one. But the accumulator keeps track of total as an argument without using stack memory on recursive calls.\n\n415."
    },
    {
      "text": "How to detect if a function is called as constructor",
      "options": [
        {
          "text": "dir()` is used to display an interactive list of the properties of the specified JavaScript object as JSON",
          "is_correct": false
        },
        {
          "text": "The below `Location` object properties can be used to access URL components of the page,\n\n      1",
          "is_correct": false
        },
        {
          "text": "**Parsing**: Transforming a JSON-formatted string into a native JavaScript object",
          "is_correct": false
        },
        {
          "text": "target` pseudo-property to detect whether a function was called as a constructor(using the new operator) or as a regular function call",
          "is_correct": true
        }
      ],
      "explanation": "You can use `new.target` pseudo-property to detect whether a function was called as a constructor(using the new operator) or as a regular function call.\n\n     1. If a constructor or function invoked using the new operator, new.target returns a reference to the constructor or function.\n     2. For function calls, new.target is undefined.\n\n     ```javascript\n     function Myfunc() {\n       if (new.target) {\n         console.log(\"called with new\");\n       } else {\n         console.log(\"not called with new\");\n       }\n     }\n\n     new Myfunc(); // called with new\n     Myfunc(); // not called with new\n     Myfunc.call({}); // not called with new\n     ```\n\n417."
    },
    {
      "text": "How do you define instance and non-instance properties",
      "options": [
        {
          "text": "**Parsing**: Transforming a JSON-formatted string into a native JavaScript object",
          "is_correct": false
        },
        {
          "text": "The prototype chain is a core concept in JavaScript’s inheritance model",
          "is_correct": false
        },
        {
          "text": "The javascript parser will automatically add a semicolon while parsing the source code",
          "is_correct": false
        },
        {
          "text": "The Instance properties must be defined inside of class methods",
          "is_correct": true
        }
      ],
      "explanation": "The Instance properties must be defined inside of class methods. For example, name and age properties defined inside constructor as below,\n\n     ```javascript\n     class Person {\n       constructor(name, age) {\n         this.name = name;\n         this.age = age;\n       }\n     }\n     ```\n\n     But Static(class) and prototype data properties must be defined outside of the ClassBody declaration. Let's assign the age value for Person class as below,\n\n     ```javascript\n     Person.staticAge = 30;\n     Person.prototype.prototypeAge = 40;\n     ```\n\n423."
    },
    {
      "text": "What is global execution context?",
      "options": [
        {
          "text": "The execution context in JavaScript is a data structure that stores the information necessary for executing a piece of code",
          "is_correct": false
        },
        {
          "text": "The global execution context is the default or first execution context that is created by the JavaScript engine before any code is executed(i",
          "is_correct": true
        },
        {
          "text": "You can use the `String",
          "is_correct": false
        },
        {
          "text": "JavaScript doesn’t support namespaces by default",
          "is_correct": false
        }
      ],
      "explanation": "The global execution context is the default or first execution context that is created by the JavaScript engine before any code is executed(i.e, when the file first loads in the browser). All the global code that is not inside a function or object will be executed inside this global execution context. Since JS engine is single threaded there will be only one global environment and there will be only one global execution context.\n\n     For example, the below code other than code inside any function or object is executed inside the global execution context.\n\n     ```javascript\n     var x = 10;\n\n     function A() {\n       console.log(\"Start function A\");\n\n       function B() {\n         console.log(\"In function B\");\n       }\n\n       B();\n     }\n\n     A();\n\n     console.log(\"GlobalContext\");\n     ```\n\n436."
    },
    {
      "text": "What is optional chaining?",
      "options": [
        {
          "text": "Event capturing is a phase of event propagation in which an event is first intercepted by the outermost ancestor element, then travels downward through the DOM hierarchy until it reaches the target (innermost) element",
          "is_correct": false
        },
        {
          "text": "According to MDN official docs, the optional chaining operator (?",
          "is_correct": true
        },
        {
          "text": "The main difference is that references to objects in `Set` are strong while references to objects in `WeakSet` are weak",
          "is_correct": false
        },
        {
          "text": "Regular Expressions provide a group of patterns in order to match characters",
          "is_correct": false
        }
      ],
      "explanation": "According to MDN official docs, the optional chaining operator (?.) permits reading the value of a property located deep within a chain of connected objects without having to expressly validate that each reference in the chain is valid.\n\n     The ?. operator is like the . chaining operator, except that instead of causing an error if a reference is nullish (null or undefined), the expression short-circuits with a return value of undefined. When used with function calls, it returns undefined if the given function does not exist.\n\n     ```js\n     const adventurer = {\n       name: \"Alice\",\n       cat: {\n         name: \"Dinah\",\n       },\n     };\n\n     const dogName = adventurer.dog?.name;\n     console.log(dogName);\n     // expected output: undefined\n\n     console.log(adventurer.someNonExistentMethod?.());\n     // expected output: undefined\n     ```\n\n440."
    },
    {
      "text": "What is an environment record?",
      "options": [
        {
          "text": "The EvalError object indicates an error regarding the global `eval()` function",
          "is_correct": false
        },
        {
          "text": "It is recommended to use semicolons after every statement in JavaScript",
          "is_correct": false
        },
        {
          "text": "Below are the list of properties available on the `Intl` object,\n\n      1",
          "is_correct": false
        },
        {
          "text": "According to ECMAScript specification 262 (9",
          "is_correct": true
        }
      ],
      "explanation": "According to ECMAScript specification 262 (9.1):\n\n     > [Environment Record](https://262.ecma-international.org/12.0/#sec-environment-records) is a specification type used to define the association of Identifiers to specific variables and functions, based upon the lexical nesting structure of ECMAScript code.\n\n     Usually an Environment Record is associated with some specific syntactic structure of ECMAScript code such as a FunctionDeclaration, a BlockStatement, or a Catch clause of a TryStatement.\n\n     Each time such code is evaluated, a new Environment Record is created to record the identifier bindings that are created by that code.\n\n441."
    },
    {
      "text": "How do you create your own bind method using either call or apply method?",
      "options": [
        {
          "text": "All objects have prototypes except two exceptions:\n      *  **Object",
          "is_correct": false
        },
        {
          "text": "The custom bind function needs to be created on Function prototype inorder to use it as other builtin functions",
          "is_correct": true
        },
        {
          "text": "The main difference between function declarations and class declarations is `hoisting`",
          "is_correct": false
        },
        {
          "text": "If you leave out the right-hand side assignment for the destructuring object, the function will look for at least one argument to be supplied when invoked",
          "is_correct": false
        }
      ],
      "explanation": "The custom bind function needs to be created on Function prototype inorder to use it as other builtin functions. This custom function should return a function similar to original bind method and the implementation of inner function needs to use apply method call.\n\n     The function which is going to bind using custom `myOwnBind` method act as the attached function(`boundTargetFunction`) and argument as the object for `apply` method call.\n\n     ```js\n     Function.prototype.myOwnBind = function (whoIsCallingMe) {\n       if (typeof this !== \"function\") {\n         throw new Error(this + \"cannot be bound as it's not callable\");\n       }\n       const boundTargetFunction = this;\n       return function () {\n         boundTargetFunction.apply(whoIsCallingMe, arguments);\n       };\n     };\n     ```\n\n445."
    },
    {
      "text": "What is referential transparency?",
      "options": [
        {
          "text": "dir()` is used to display an interactive list of the properties of the specified JavaScript object as JSON",
          "is_correct": false
        },
        {
          "text": "In modern JavaScript applications, singletons are commonly implemented using ES6 modules for their built-in caching behavior, or closures for encapsulated state management",
          "is_correct": false
        },
        {
          "text": "An expression in javascript that can be replaced by its value without affecting the behaviour of the program is called referential transparency",
          "is_correct": true
        },
        {
          "text": "You can check whether a key exists in an object or not using three approaches,\n\n      1",
          "is_correct": false
        }
      ],
      "explanation": "An expression in javascript that can be replaced by its value without affecting the behaviour of the program is called referential transparency. Pure functions are referentially transparent.\n\n```javascript\nconst add = (x, y) => x + y;\nconst multiplyBy2 = (x) => x * 2;\n\n//Now add (2, 3) can be replaced by 5.\n\nmultiplyBy2(add(2, 3));\n```\n\n447."
    },
    {
      "text": "What is module pattern?",
      "options": [
        {
          "text": "You can use `new Date()` to generate a new Date object containing the current date and time",
          "is_correct": false
        },
        {
          "text": "A property descriptor is a record which has the following attributes\n\n      1",
          "is_correct": false
        },
        {
          "text": "Module pattern is a designed pattern used to wrap a set of variables and functions together in a single scope returned as an object",
          "is_correct": true
        },
        {
          "text": "You can use innerWidth, innerHeight, clientWidth, clientHeight properties of windows, document element and document body objects to find the size of a window",
          "is_correct": false
        }
      ],
      "explanation": "Module pattern is a designed pattern used to wrap a set of variables and functions together in a single scope returned as an object. JavaScript doesn't have access specifiers similar to other languages(Java, Python, etc) to provide private scope. It uses IIFE (Immediately invoked function expression) to allow for private scopes. i.e., a closure that protect variables and methods.\n\n     The module pattern looks like below,\n\n     ```javascript\n     (function () {\n       // Private variables or functions goes here.\n\n       return {\n         // Return public variables or functions here.\n       };\n     })();\n     ```\n\n     Let's see an example of a module pattern for an employee with private and public access,\n\n     ```javascript\n     const createEmployee = (function () {\n       // Private\n       const name = \"John\";\n       const department = \"Sales\";\n       const getEmployeeName = () => name;\n       const getDepartmentName = () => department;\n\n       // Public\n       return {\n         name,\n         department,\n         getName: () => getEmployeeName(),\n         getDepartment: () => getDepartmentName(),\n       };\n     })();\n\n     console.log(createEmployee.name);\n     console.log(createEmployee.department);\n     console.log(createEmployee.getName());\n     console.log(createEmployee.getDepartment());\n     ```\n\n     **Note:** It mimic the concepts of classes with private variables and methods.\n\n450."
    },
    {
      "text": "What is the purpose of the this keyword in JavaScript?",
      "options": [
        {
          "text": "The `this` keyword in JavaScript refers to **the object that is executing the current function**",
          "is_correct": true
        },
        {
          "text": "WebWorkers don't have access to below javascript objects since they are defined in an external files\n\n    1",
          "is_correct": false
        },
        {
          "text": "The constructor method is a special method for creating and initializing an object created within a class",
          "is_correct": false
        },
        {
          "text": "Two strings are strictly equal if they have exactly the same sequence of characters and length",
          "is_correct": false
        }
      ],
      "explanation": "The `this` keyword in JavaScript refers to **the object that is executing the current function**. Its value is determined by **how a function is called**, not where it is defined.  `this` is essential for writing object-oriented and event-driven code, as it allows methods to interact with the data of the object they belong to.\n\n  **Example 1: this in a Global Context**\n\n  ```javascript\n  console.log(this);\n  ```\n\n  - In a global context, this refers to the global object (e.g., window in a browser).\n\n  **Example 2: this in a Function**\n\n  ```javascript\n  function displayThis() {\n    console.log(this);\n  }\n\n  displayThis();\n  ```\n\n  - In a regular function, this refers to the global object(window in browser and global in nodejs) for non-strict mode.  In strict mode, it's value is undefined.\n\n  **Example 3: this in a Method**\n\n  ```javascript\n  const person = {\n    name: \"John\",\n    greet: function () {\n      console.log(\"Hello, \" + this.name);\n    },\n  };\n\n  person.greet();\n  ```\n\n  - In a method, this refers to the object that owns the method (person in the case).\n\n  **Example 4: this in an Event Handler**\n\n  ```javascript\n   document.getElementById(\"myButton\").addEventListener(\"click\", function () {\n            console.log(this);\n   });\n  ```\n\n  - In an event handler, this refers to the element that triggered the event (the button in this case).\n\n  **Example 5: `this` with Arrow Functions**\n\n  ```javascript\n        const obj = {\n          age: 42,\n          regular: function() { console.log(this.age); },\n          arrow: () => { console.log(this.age); }\n        };\n        obj.regular(); // 42 (this refers to obj)\n        obj.arrow();   // undefined (this refers to the outer scope, not obj)\n  ```\n  - Arrow functions do not have their own `this` binding; they inherit it from their surrounding (lexical) context.\n\n  **Example 6: this in Constructor Functions / Classes**\n    \n  ```javascript\n    function Person(name) {\n      this.name = name;\n    }\n    \n    const p1 = new Person('Sudheer');\n    console.log(p1.name); // Sudheer\n  ```\n   - When used with new, this refers to the newly created object.\n\n453."
    },
    {
      "text": "What are the phases of execution context?",
      "options": [
        {
          "text": "You can check whether a key exists in an object or not using three approaches,\n\n      1",
          "is_correct": false
        },
        {
          "text": "The execution context in JavaScript is a data structure that stores the information necessary for executing a piece of code",
          "is_correct": true
        },
        {
          "text": "You can programmatically get the image and check the dimensions(width and height) using Javascript",
          "is_correct": false
        },
        {
          "text": "A decorator is an expression that evaluates to a function and that takes the target, name, and decorator descriptor as arguments",
          "is_correct": false
        }
      ],
      "explanation": "The execution context in JavaScript is a data structure that stores the information necessary for executing a piece of code. It includes the code itself, the values of the variables used in the code, and the scope chain. The scope chain is a list of objects that are used to resolve variable names.\n\nThe execution context has two phases:\n\n- Creation phase: In this phase, the JavaScript engine creates the execution context and sets up the script's environment. This includes creating the variable object and the scope chain.\n- Execution phase: In this phase, the JavaScript engine executes the code in the execution context. This includes evaluating expressions, assigning values to variables, and calling functions.\n\nThe execution context is created when a function is called. The function's code is then executed in the execution context. When the function returns, the execution context is destroyed.\n\n455."
    },
    {
      "text": "What are the optimization techniques of V8 engine?",
      "options": [
        {
          "text": "defineProperty()` static method is used to define a new property directly on an object, or modify an existing property on an object, and returns the object",
          "is_correct": false
        },
        {
          "text": "Even though JavaScript lacks namespaces, we can use Objects, an IIFE (Immediately Invoked Function Expression) or `let`/`const` to create namespaces",
          "is_correct": false
        },
        {
          "text": "Due to hositing feature, the variables declared with `var` will have `undefined` value in the creation phase so the outer variable `currentCity` will get same `undefined` value",
          "is_correct": false
        },
        {
          "text": "V8 engine uses the below optimization techniques",
          "is_correct": true
        }
      ],
      "explanation": "V8 engine uses the below optimization techniques.\n\n     1. **Inline expansion:** It is a compiler optimization by replacing the function calls with the corresponding function blocks.\n     2. **Copy elision:** This is a compiler optimization method to prevent expensive extra objects from being duplicated or copied.\n     3. **Inline caching:** It is a runtime optimization technique where it caches the execution of older tasks those can be lookup while executing the same task in the future.\n\n457."
    },
    {
      "text": "Give an example of statements affected by automatic semicolon insertion?",
      "options": [
        {
          "text": "The javascript parser will automatically add a semicolon while parsing the source code",
          "is_correct": true
        },
        {
          "text": "IIFE(Immediately Invoked Function Expression) is just like any other function expression which won't be hoisted",
          "is_correct": false
        },
        {
          "text": "The \"constructor\" in a class is a special method and it should be defined only once in a class",
          "is_correct": false
        },
        {
          "text": "The Error constructor creates an error object and the instances of error objects are thrown when runtime errors occur",
          "is_correct": false
        }
      ],
      "explanation": "The javascript parser will automatically add a semicolon while parsing the source code. For example, the below common statements affected by Automatic Semicolon Insertion(ASI).\n\n     1. An empty statement\n     2. var statement\n     3. An expression statement\n     4. do-while statement\n     5. continue statement\n     6. break statement\n     7. return statement\n     8. throw statement\n\n462."
    },
    {
      "text": "What are the event phases of a browser?",
      "options": [
        {
          "text": "The `trim` method of string prototype is used to trim on both sides of a string",
          "is_correct": false
        },
        {
          "text": "You can use the `super` keyword to call the constructor of a parent class",
          "is_correct": false
        },
        {
          "text": "You can use ECMAScript 6's `String",
          "is_correct": false
        },
        {
          "text": "There are 3 phases in the lifecycle of an event propagation in JavaScript,\n\n     1",
          "is_correct": true
        }
      ],
      "explanation": "There are 3 phases in the lifecycle of an event propagation in JavaScript,\n\n     1. **Capturing phase:** This phase goes down gradually from the top of the DOM tree to the target element when a nested element clicked. Before the click event reaching the final destination element, the click event of each parent's element must be triggered.\n\n     2. **Target phase:** This is the phase where the event originally occurred reached the target element .\n\n     3. **Bubbling phase:** This is reverse of the capturing phase. In this pase, the event bubbles up from the target element through it's parent element, an ancestor and goes all the way to the global window object.\n\n     The pictorial representation of these 3 event phases in DOM looks like below,\n\n     ![Screenshot](images/event-flow.png)\n\n463."
    },
    {
      "text": "What are hidden classes?",
      "options": [
        {
          "text": "The main difference between function declarations and class declarations is `hoisting`",
          "is_correct": false
        },
        {
          "text": "Since JavaScript is a dynamic programming language, you can add or remove properties and methods from objects on the fly at runtime",
          "is_correct": true
        },
        {
          "text": "If an object is frozen using the `Object",
          "is_correct": false
        },
        {
          "text": "Event bubbling is a type of event propagation in which an event first triggers on the innermost target element (the one the user interacted with), and then bubbles up through its ancestors in the DOM hierarchy — eventually reaching the outermost elements, like the document or window",
          "is_correct": false
        }
      ],
      "explanation": "Since JavaScript is a dynamic programming language, you can add or remove properties and methods from objects on the fly at runtime. This nature of JavaScript increases the dynamic dictionary lookups(because objects implemented as HashTables in memory) for retrieving a property on an object.\n\n     Let's consider the following example to see how the additional properties `age` and `gender` added at runtime.\n\n     ```javascript\n     function Person(name) {\n       this.name = name;\n     }\n\n     var person1 = new Person(\"John\");\n     var person2 = new Person(\"Randy\");\n\n     person1.age = 40;\n     person1.gender = \"Male\";\n\n     person2.gender = \"Female\";\n     person2.age = 50;\n     ```\n\n     As a result, this behavior leads to lower JavaScript performance compared to the contiguous buffer method used in non-dynamic languages. The V8 engine provided a solution named **hidden classes** to optimize the access time when retrieving a property on an object. This optimization is achieved by sharing hidden classes among objects created in a similar fashion. These hidden classes are attached to each and every object to track its shape.\n\n     When V8 engine sees the constructor function(e.g, Person) is declared, it creates a hidden class (let's say Class01) without any offsets. Once the first property assignment statement (`this.name = name`) is executed, V8 engine will create a new hidden class (let's say Class02), inheriting all properties from the previous hidden class (Class01), and assign the property to offset 0. This process enables compiler to skip dictionary lookup when you try to retrieve the same property(i.e, name). Instead, V8 will directly point to Class02. The same procedure happens when you add new properties to the object.\n\n     For example, adding `age` and `gender` properties to `Person` constructor leads to transition of hidden classes(Class02 -> Class03 -> Class04). If you create a second object(Person2) based on the same Person object, both Class01 and Class02 hidden classes are going to be shared. However, the hidden classes Class03 and Class04 cannot be shared because second object has been modified with a different order of properties assignment.\n\n     Since both the objects(person1 and person2) do not share the hidden classes, now V8 engine cannot use **Inline Caching** technique for the faster access of properties.\n\n465."
    },
    {
      "text": "What is inline caching?",
      "options": [
        {
          "text": "The Error constructor creates an error object and the instances of error objects are thrown when runtime errors occur",
          "is_correct": false
        },
        {
          "text": "Inline caching is an optimization technique based on the observation that repeated calls to same function tends to occur on same type of objects",
          "is_correct": true
        },
        {
          "text": "defineProperty()` static method is used to define a new property directly on an object, or modify an existing property on an object, and returns the object",
          "is_correct": false
        },
        {
          "text": "Some of the applications of Object's `is` method are follows,\n\n      1",
          "is_correct": false
        }
      ],
      "explanation": "Inline caching is an optimization technique based on the observation that repeated calls to same function tends to occur on same type of objects. The V8 compiler stores a cache of the type of objects that were passed as a parameter in recent method calls. Upon next time when same function is called, compiler can directly search for the type in cache.\n\nLet's consider an example where the compiler stores the shape type in cache for repeated calls in the loop.\n\n```js\nlet shape = { width: 30, height: 20 }; // Compiler store the type in cache as { width: , height: } after repeated calls\n\nfunction area(obj) {\n  //Calculate area\n}\nfor (let i = 0; i < 100; i++) {\n  area(shape);\n}\n```\n\nAfter few successful calls of the same area method to its same hidden class, V8 engine omits the hidden class lookup and simply adds the offset of the property to the object pointer itself. As a result, it increases the execution speed.\n\nThere are mainly 3 types of inline caching possible:\n\n1. Monomorphic: This is a optimized caching technique in which there can be always same type of objects passed.\n2. Polymorphic: This ia slightly optimized caching technique in which limited number of different types of objects can be passed.\n3. Megamorphic: It is an unoptimized caching in which any number of different objects can be passed.\n\n466."
    },
    {
      "text": "How to detect system dark mode in javascript?",
      "options": [
        {
          "text": "The combination of `Window",
          "is_correct": true
        },
        {
          "text": "Below are the list of placeholders available from console object,\n\n      1",
          "is_correct": false
        },
        {
          "text": "The main difference between function declarations and class declarations is `hoisting`",
          "is_correct": false
        },
        {
          "text": "You can use the `Intl",
          "is_correct": false
        }
      ],
      "explanation": "The combination of `Window.matchMedia()` utility method along with media query is used to check if the user has selected a dark color scheme in their operating system settings or not. The CSS media query `prefers-color-scheme` needs to be passed to identify system color theme.\n\n     The following javascript code describes the usage,\n\n     ```javascript\n     const hasDarkColorScheme = () =>\n       window.matchMedia &&\n       window.matchMedia(\"(prefers-color-scheme: dark)\").matches;\n     ```\n\n     You can also watch changes to system color scheme using `addEventListener`,\n\n     ```javascript\n     window\n       .matchMedia(\"(prefers-color-scheme: dark)\")\n       .addEventListener(\"change\", (event) => {\n         const theme = event.matches ? \"dark\" : \"light\";\n       });\n     ```\n\n     **Note:** The matchMedia method returns **MediaQueryList** object stores information from a media query.\n\n469."
    },
    {
      "text": "What is the purpose of requestAnimationFrame method?",
      "options": [
        {
          "text": "The requestAnimationFrame() method in JavaScript is used to schedule a function to be called before the next repaint of the browser window, allowing you to create smooth, efficient animations",
          "is_correct": true
        },
        {
          "text": "Both are totally unrelated programming languages and no relation between them",
          "is_correct": false
        },
        {
          "text": "You can use the `import",
          "is_correct": false
        },
        {
          "text": "JavaScript provided a trim method on string types to trim any whitespaces present at the beginning or ending of the string",
          "is_correct": false
        }
      ],
      "explanation": "The requestAnimationFrame() method in JavaScript is used to schedule a function to be called before the next repaint of the browser window, allowing you to create smooth, efficient animations. It's primarily used for animations and visual updates, making it an essential tool for improving performance when you're animating elements on the web.\n\n```javascript\nconst element = document.getElementById(\"myElement\");\nfunction animate() {\n  let currentPosition = parseInt(window.getComputedStyle(element).left, 10);\n\n  // Move the element 2px per frame\n  currentPosition += 2;\n  element.style.left = currentPosition + \"px\";\n  // If the element hasn't moved off-screen, request the next frame\n  if (currentPosition < window.innerWidth) {\n    requestAnimationFrame(animate);\n  }\n}\n// Start the animation\nrequestAnimationFrame(animate);\n```\n\n470."
    },
    {
      "text": "How to find the number of parameters expected by a function?",
      "options": [
        {
          "text": "Below are the list of properties available on the `Intl` object,\n\n      1",
          "is_correct": false
        },
        {
          "text": "history object contains the browser's history",
          "is_correct": false
        },
        {
          "text": "The function's object has a **length** property which tells you how many formal parameters expected by a function",
          "is_correct": true
        },
        {
          "text": "There are 3 phases in the lifecycle of an event propagation in JavaScript,\n\n     1",
          "is_correct": false
        }
      ],
      "explanation": "The function's object has a **length** property which tells you how many formal parameters expected by a function. This is a static value defined by the function, not the number of arguments the function is called with(**arguments.length**). The basic usage of length propery is,\n\n```javascript\nfunction multiply(x, y) {\n  return x * y;\n}\n\nfunction sum(a, b, c) {\n  return a + b + c;\n}\n\nconsole.log(multiply.length); //2\nconsole.log(sum.length); //3\n```\n\nBut there are few important rules which needs to be noted while using length property.\n\n1. **Default values:** Only the parameters which exists before a default value are considered.\n   ```javascript\n   function sum(a, b = 2, c = 3) {\n     return a + b + c;\n   }\n   console.log(sum.length); // 1\n   ```\n2. **Rest params:** The rest parameters are excluded with in length property.\n   ```javascript\n   function sum(a, b, ...moreArgs) {\n     let total = a + b;\n     for (const arg of moreArgs) {\n       total += arg;\n     }\n     return total;\n   }\n   console.log(sum.length); // 2\n   ```\n3. **Destructuring patterns:** Each destructuring pattern counted as a single parameter.\n\n   ```javascript\n   function func([a, b], { x, y }) {\n     console.log(a + b, x, y);\n   }\n\n   console.log(func.length); // 2\n   ```\n\n**Note:** The Function constructor is itself a function object and it has a length property of 1.\n\n472."
    },
    {
      "text": "What is globalThis, and what is the importance of it?",
      "options": [
        {
          "text": "In the Object-oriented paradigm, an existing API contains certain elements that are not intended to be extended, modified, or re-used outside of their current context",
          "is_correct": false
        },
        {
          "text": "It is recommended to use semicolons after every statement in JavaScript",
          "is_correct": false
        },
        {
          "text": "Nowadays JavaScript language is used in a wide variety of environments and each environment has its own object model",
          "is_correct": true
        },
        {
          "text": "Module pattern is a designed pattern used to wrap a set of variables and functions together in a single scope returned as an object",
          "is_correct": false
        }
      ],
      "explanation": "Nowadays JavaScript language is used in a wide variety of environments and each environment has its own object model. Due to this fact, there are different ways(syntax) to access the global object.\n\n     1. In web browser, the global object is accessible via `window`, `self`, or `frames`.\n     2. In Node environment, you have to use `global`.\n     3. In Web workers, the global object is available through `self`.\n\nThe `globalThis` property provides a standard way of accessing the global object without writing various code snippet to support multiple environments. For example, the global object retuned from multiple environments as shown below,\n\n```javascript\n//1. browser environment\nconsole.log(globalThis); // => Window {...}\n\n//2. node.js environment\nconsole.log(globalThis); // => Object [global] {...}\n\n//3. web worker environment\nconsole.log(globalThis); // => DedicatedWorkerGlobalScope {...}\n```\n\n473."
    },
    {
      "text": "#Answer: 4",
      "options": [
        {
          "text": "The main points in the above code snippets are,\n\n1",
          "is_correct": true
        },
        {
          "text": "An expression in javascript that can be replaced by its value without affecting the behaviour of the program is called referential transparency",
          "is_correct": false
        },
        {
          "text": "When receiving the data from a web server, the data is always in a string format",
          "is_correct": false
        },
        {
          "text": "In ES5, it will throw a TypeError exception if the obj parameter isn't an object",
          "is_correct": false
        }
      ],
      "explanation": "The main points in the above code snippets are,\n\n1. You can see function expression instead function declaration inside if statement. So it always returns true.\n2. Since it is not declared(or assigned) anywhere, f is undefined and typeof f is undefined too.\n\nIn other words, it is same as\n\n```javascript\nvar y = 1;\nif (\"foo\") {\n  y += typeof f;\n}\nconsole.log(y);\n```\n\n**Note:** It returns 1object for MS Edge browser"
    },
    {
      "text": "#Answer: 3",
      "options": [
        {
          "text": "WebWorkers don't have access to below javascript objects since they are defined in an external files\n\n    1",
          "is_correct": false
        },
        {
          "text": "isFrozen()` method is used to determine if an object is frozen or not",
          "is_correct": false
        },
        {
          "text": "This is a semicolon issue",
          "is_correct": true
        },
        {
          "text": "The requestAnimationFrame() method in JavaScript is used to schedule a function to be called before the next repaint of the browser window, allowing you to create smooth, efficient animations",
          "is_correct": false
        }
      ],
      "explanation": "This is a semicolon issue. Normally semicolons are optional in JavaScript. So if there are any statements(in this case, return) missing semicolon, it is automatically inserted immediately. Hence, the function returned as undefined.\n\nWhereas if the opening curly brace is along with the return keyword then the function is going to be returned as expected.\n\n```javascript\nfunction foo() {\n  return {\n    message: \"Hello World\",\n  };\n}\nconsole.log(foo()); // {message: \"Hello World\"}\n```"
    },
    {
      "text": "#Answer: 1",
      "options": [
        {
          "text": "If a function is called with `undefined`, the `undefined` value is treated as a parameter",
          "is_correct": false
        },
        {
          "text": "Below are the list of properties available on the `Intl` object,\n\n      1",
          "is_correct": false
        },
        {
          "text": "ES6 provides method definitions and property shorthands for objects",
          "is_correct": true
        },
        {
          "text": "Cookies are used to remember information about the user profile(such as username)",
          "is_correct": false
        }
      ],
      "explanation": "ES6 provides method definitions and property shorthands for objects. So both prop2 and prop3 are treated as regular function values."
    },
    {
      "text": "#Answer: 1",
      "options": [
        {
          "text": "Browsers provide an XMLHttpRequest object which can be used to make synchronous HTTP requests from JavaScript",
          "is_correct": false
        },
        {
          "text": "Due to hositing feature, the variables declared with `var` will have `undefined` value in the creation phase so the outer variable `currentCity` will get same `undefined` value",
          "is_correct": false
        },
        {
          "text": "Arrow functions do not have an `arguments, super, this, or new",
          "is_correct": true
        },
        {
          "text": "Each context(global or functional) has it's own variable environment and the callstack of variables in a LIFO order",
          "is_correct": false
        }
      ],
      "explanation": "Arrow functions do not have an `arguments, super, this, or new.target` bindings. So any reference to `arguments` variable tries to resolve to a binding in a lexically enclosing environment. In this case, the arguments variable is not defined outside of the arrow function. Hence, you will receive a reference error.\n\nWhere as the normal function provides the number of arguments passed to the function\n\n```javascript\nconst func = function () {\n  return arguments.length;\n};\nconsole.log(func(1, 2, 3));\n```\n\nBut If you still want to use an arrow function then rest operator on arguments provides the expected arguments\n\n```javascript\nconst arrowFunc = (...args) => args.length;\nconsole.log(arrowFunc(1, 2, 3));\n```"
    },
    {
      "text": "#Answer: 2",
      "options": [
        {
          "text": "Yes, JavaScript is a case sensitive language",
          "is_correct": false
        },
        {
          "text": "In order to be consistent with functions like `String",
          "is_correct": true
        },
        {
          "text": "When receiving the data from a web server, the data is always in a string format",
          "is_correct": false
        },
        {
          "text": "Below are the list of properties available on the `Intl` object,\n\n      1",
          "is_correct": false
        }
      ],
      "explanation": "In order to be consistent with functions like `String.prototype.padStart`, the standard method name for trimming the whitespaces is considered as `trimStart`. Due to web web compatibility reasons, the old method name 'trimLeft' still acts as an alias for 'trimStart'. Hence, the prototype for 'trimLeft' is always 'trimStart'"
    },
    {
      "text": "#Answer: 1",
      "options": [
        {
          "text": "It is known that not all JavaScript libraries or frameworks have TypeScript declaration files",
          "is_correct": false
        },
        {
          "text": "Since `Set` object is a collection of unique values, it won't allow duplicate values in the collection",
          "is_correct": true
        },
        {
          "text": "No, javascript does not natively support enums",
          "is_correct": false
        },
        {
          "text": "There are 3 possible ways to check whether a string contains a substring or not,\n\n      1",
          "is_correct": false
        }
      ],
      "explanation": "Since `Set` object is a collection of unique values, it won't allow duplicate values in the collection. At the same time, it is case sensitive data structure."
    },
    {
      "text": "#Answer: 3",
      "options": [
        {
          "text": "There are 3 phases in the lifecycle of an event propagation in JavaScript,\n\n     1",
          "is_correct": false
        },
        {
          "text": "The Error constructor creates an error object and the instances of error objects are thrown when runtime errors occur",
          "is_correct": false
        },
        {
          "text": "Symbol follows below conventions,\n\n1",
          "is_correct": true
        },
        {
          "text": "When you apply 'use strict'; syntax, some of the below cases will throw a SyntaxError before executing the script\n\n      1",
          "is_correct": false
        }
      ],
      "explanation": "Symbol follows below conventions,\n\n1. Every symbol value returned from Symbol() is unique irrespective of the optional string.\n2. `Symbol.for()` function creates a symbol in a global symbol registry list. But it doesn't necessarily create a new symbol on every call, it checks first if a symbol with the given key is already present in the registry and returns the symbol if it is found. Otherwise a new symbol created in the registry.\n\n**Note:** The symbol description is just useful for debugging purposes."
    },
    {
      "text": "#Answer: 1",
      "options": [
        {
          "text": "There are 3 possible ways to check whether a string contains a substring or not,\n\n      1",
          "is_correct": false
        },
        {
          "text": "You can check whether a key exists in an object or not using three approaches,\n\n      1",
          "is_correct": false
        },
        {
          "text": "`Symbol` is a just a standard function and not an object constructor(unlike other primitives new Boolean, new String and new Number)",
          "is_correct": true
        },
        {
          "text": "Symbol follows below conventions,\n\n1",
          "is_correct": false
        }
      ],
      "explanation": "`Symbol` is a just a standard function and not an object constructor(unlike other primitives new Boolean, new String and new Number). So if you try to call it with the new operator will result in a TypeError"
    },
    {
      "text": "#Answer: 2",
      "options": [
        {
          "text": "Using constructors, `new",
          "is_correct": true
        },
        {
          "text": "If you leave out the right-hand side assignment for the destructuring object, the function will look for at least one argument to be supplied when invoked",
          "is_correct": false
        },
        {
          "text": "You can perform HTML form validation automatically without using javascript",
          "is_correct": false
        },
        {
          "text": "The below `Location` object properties can be used to access URL components of the page,\n\n      1",
          "is_correct": false
        }
      ],
      "explanation": "Using constructors, `new.target` refers to the constructor (points to the class definition of class which is initialized) that was directly invoked by new. This also applies to the case if the constructor is in a parent class and was delegated from a child constructor."
    },
    {
      "text": "#Answer: 1",
      "options": [
        {
          "text": "JavaScript provided a trim method on string types to trim any whitespaces present at the beginning or ending of the string",
          "is_correct": false
        },
        {
          "text": "The object property follows below rules,\n\n1",
          "is_correct": true
        },
        {
          "text": "isSealed()` method is used to determine if an object is sealed or not",
          "is_correct": false
        },
        {
          "text": "Yes, you can apply CSS styles to console messages similar to html text on the web page",
          "is_correct": false
        }
      ],
      "explanation": "The object property follows below rules,\n\n1. The object properties can be retrieved and assigned to a variable with a different name\n2. The property assigned a default value when the retrieved value is `undefined`"
    },
    {
      "text": "#Answer: 2",
      "options": [
        {
          "text": "You can use ECMAScript 6's `String",
          "is_correct": false
        },
        {
          "text": "The object property follows below rules,\n\n1",
          "is_correct": false
        },
        {
          "text": "defineProperty()` static method is used to define a new property directly on an object, or modify an existing property on an object, and returns the object",
          "is_correct": false
        },
        {
          "text": "If you leave out the right-hand side assignment for the destructuring object, the function will look for at least one argument to be supplied when invoked",
          "is_correct": true
        }
      ],
      "explanation": "If you leave out the right-hand side assignment for the destructuring object, the function will look for at least one argument to be supplied when invoked. Otherwise you will receive an error `Error: Cannot read property 'length' of undefined` as mentioned above.\n\nYou can avoid the error with either of the below changes,\n\n1. **Pass at least an empty object:**\n\n```javascript\nfunction area({ length = 10, width = 20 }) {\n  console.log(length * width);\n}\n\narea({});\n```\n\n2. **Assign default empty object:**\n\n```javascript\nfunction area({ length = 10, width = 20 } = {}) {\n  console.log(length * width);\n}\n\narea();\n```"
    },
    {
      "text": "#Answer: 3",
      "options": [
        {
          "text": "Scope is the accessibility of variables, functions, and objects in some particular part of your code during runtime",
          "is_correct": false
        },
        {
          "text": "Cookies are used to remember information about the user profile(such as username)",
          "is_correct": false
        },
        {
          "text": "If the function argument is set implicitly(not passing argument) or explicitly to undefined, the value of the argument is the default parameter",
          "is_correct": true
        },
        {
          "text": "The function `printHello` is hoisted to the top of the global scope and prints \"Hello\" to the console",
          "is_correct": false
        }
      ],
      "explanation": "If the function argument is set implicitly(not passing argument) or explicitly to undefined, the value of the argument is the default parameter. Whereas for other falsy values('' or null), the value of the argument is passed as a parameter.\n\nHence, the result of function calls categorized as below,\n\n1. The first two function calls logs number type since the type of default value is number\n2. The type of '' and null values are string and object type respectively."
    },
    {
      "text": "#Answer: 4",
      "options": [
        {
          "text": "You can change inline style or classname of a HTML element using javascript DOM-manipulation\n\n      1",
          "is_correct": false
        },
        {
          "text": "Generators are not constructible type",
          "is_correct": true
        },
        {
          "text": "An expression in javascript that can be replaced by its value without affecting the behaviour of the program is called referential transparency",
          "is_correct": false
        },
        {
          "text": "Heap(Or memory heap) is the memory location where objects are stored when we define variables",
          "is_correct": false
        }
      ],
      "explanation": "Generators are not constructible type. But if you still proceed to do, there will be an error saying \"TypeError: myGenFunc is not a constructor\""
    },
    {
      "text": "#Answer: 1",
      "options": [
        {
          "text": "The `extends` keyword is used in class declarations/expressions to create a class which is a child of another class",
          "is_correct": false
        },
        {
          "text": "You can use the `super` keyword to call the constructor of a parent class",
          "is_correct": false
        },
        {
          "text": "The constructor method is a special method for creating and initializing an object created within a class",
          "is_correct": false
        },
        {
          "text": "A return statement in a generator function will make the generator finish",
          "is_correct": true
        }
      ],
      "explanation": "A return statement in a generator function will make the generator finish. If a value is returned, it will be set as the value property of the object and done property to true. When a generator is finished, subsequent next() calls return an object of this form: `{value: undefined, done: true}`."
    },
    {
      "text": "#Answer: 2",
      "options": [
        {
          "text": "An expression in javascript that can be replaced by its value without affecting the behaviour of the program is called referential transparency",
          "is_correct": false
        },
        {
          "text": "This is a semicolon issue",
          "is_correct": false
        },
        {
          "text": "Unlike function declarations, class declarations are not hoisted",
          "is_correct": true
        },
        {
          "text": "The `uneval()` is an builtin function which is used to create a string representation of the source code of an Object",
          "is_correct": false
        }
      ],
      "explanation": "Unlike function declarations, class declarations are not hoisted. i.e, First You need to declare your class and then access it, otherwise it will throw a ReferenceError \"Uncaught ReferenceError: Square is not defined\".\n\n**Note:** Class expressions also applies to the same hoisting restrictions of class declarations."
    },
    {
      "text": "#Answer: 4",
      "options": [
        {
          "text": "You need to use date",
          "is_correct": false
        },
        {
          "text": "When a regular or prototype method is called without a value for **this**, the methods return an initial this value if the value is not undefined",
          "is_correct": true
        },
        {
          "text": "You can use the `Object",
          "is_correct": false
        },
        {
          "text": "A return statement in a generator function will make the generator finish",
          "is_correct": false
        }
      ],
      "explanation": "When a regular or prototype method is called without a value for **this**, the methods return an initial this value if the value is not undefined. Otherwise global window object will be returned. In our case, the initial `this` value is undefined so both methods return window objects."
    },
    {
      "text": "#Answer: 3",
      "options": [
        {
          "text": "Below are the some of main applications of `Object",
          "is_correct": false
        },
        {
          "text": "The super keyword is used to call methods of a superclass",
          "is_correct": true
        },
        {
          "text": "A `WeakSet` is used to store a collection of weakly(weak references) held objects",
          "is_correct": false
        },
        {
          "text": "The main difference is that references to objects in `Set` are strong while references to objects in `WeakSet` are weak",
          "is_correct": false
        }
      ],
      "explanation": "The super keyword is used to call methods of a superclass. Unlike other languages the super invocation doesn't need to be a first statement. i.e, The statements will be executed in the same order of code."
    },
    {
      "text": "#Answer: 2",
      "options": [
        {
          "text": "Even though we used constant variables, the content of it is an object and the object's contents (e",
          "is_correct": true
        },
        {
          "text": "All objects have prototypes except two exceptions:\n      *  **Object",
          "is_correct": false
        },
        {
          "text": "The functions which are created with `Function constructor` do not create closures to their creation contexts but they are always created in the global scope",
          "is_correct": false
        },
        {
          "text": "In JavaScript, `call`, `apply`, and `bind` are methods that allow you to control the context (`this` value) in which a function is executed",
          "is_correct": false
        }
      ],
      "explanation": "Even though we used constant variables, the content of it is an object and the object's contents (e.g properties) can be altered. Hence, the change is going to be valid in this case."
    },
    {
      "text": "#Answer: 1",
      "options": [
        {
          "text": "Since JavaScript is a dynamic programming language, you can add or remove properties and methods from objects on the fly at runtime",
          "is_correct": false
        },
        {
          "text": "The typeof operator on any primitive returns a string value",
          "is_correct": true
        },
        {
          "text": "history object contains the browser's history",
          "is_correct": false
        },
        {
          "text": "The `extends` keyword is used in class declarations/expressions to create a class which is a child of another class",
          "is_correct": false
        }
      ],
      "explanation": "The typeof operator on any primitive returns a string value. So even if you apply the chain of typeof operators on the return value, it is always string."
    },
    {
      "text": "#Answer: 1",
      "options": [
        {
          "text": "Eventhough the above function returns the same result for the same arguments(input) that are passed in the function, the `console",
          "is_correct": false
        },
        {
          "text": "If the function argument is set implicitly(not passing argument) or explicitly to undefined, the value of the argument is the default parameter",
          "is_correct": false
        },
        {
          "text": "Each context(global or functional) has it's own variable environment and the callstack of variables in a LIFO order",
          "is_correct": false
        },
        {
          "text": "The type of operator on new Number always returns object",
          "is_correct": true
        }
      ],
      "explanation": "1. The type of operator on new Number always returns object. i.e, typeof new Number(0) --> object.\n2. Objects are always truthy in if block\n\nHence the above code block always goes to if section."
    },
    {
      "text": "#Answer: 4",
      "options": [
        {
          "text": "It is known that not all JavaScript libraries or frameworks have TypeScript declaration files",
          "is_correct": false
        },
        {
          "text": "The function `printHello` is hoisted to the top of the global scope and prints \"Hello\" to the console",
          "is_correct": false
        },
        {
          "text": "You can use the `super` keyword to call the constructor of a parent class",
          "is_correct": false
        },
        {
          "text": "It returns undefined for non-strict mode and returns Error for strict mode",
          "is_correct": true
        }
      ],
      "explanation": "It returns undefined for non-strict mode and returns Error for strict mode. In non-strict mode, the wrapper object is going to be created and get the mentioned property. But the object get disappeared after accessing the property in next line."
    },
    {
      "text": "#Answer: 4",
      "options": [
        {
          "text": "WebWorkers don't have access to below javascript objects since they are defined in an external files\n\n    1",
          "is_correct": false
        },
        {
          "text": "The main difference between function declarations and class declarations is `hoisting`",
          "is_correct": false
        },
        {
          "text": "There are 3 possible ways to check whether a string contains a substring or not,\n\n      1",
          "is_correct": false
        },
        {
          "text": "IIFE(Immediately Invoked Function Expression) is just like any other function expression which won't be hoisted",
          "is_correct": true
        }
      ],
      "explanation": "IIFE(Immediately Invoked Function Expression) is just like any other function expression which won't be hoisted. Hence, there will be a reference error for message call.\nThe behavior would be the same with below function expression of message1,\n\n```javascript\nconsole.log(name);\nconsole.log(message());\nvar name = 'John';\nvar message = function () {\n   console.log('Hello John: Welcome');\n});\n```"
    },
    {
      "text": "#Answer: 3",
      "options": [
        {
          "text": "Due to hositing feature, the variables declared with `var` will have `undefined` value in the creation phase so the outer variable `currentCity` will get same `undefined` value",
          "is_correct": true
        },
        {
          "text": "All objects have prototypes except two exceptions:\n      *  **Object",
          "is_correct": false
        },
        {
          "text": "`Native objects` are objects that are part of the JavaScript language defined by the ECMAScript specification",
          "is_correct": false
        },
        {
          "text": "Scope is the accessibility of variables, functions, and objects in some particular part of your code during runtime",
          "is_correct": false
        }
      ],
      "explanation": "Due to hositing feature, the variables declared with `var` will have `undefined` value in the creation phase so the outer variable `currentCity` will get same `undefined` value. But after few lines of code JavaScript engine found a new function call(`changeCurrentCity()`) to update the current city with `var` re-declaration. Since each function call will create a new execution context, the same variable will have `undefined` value before the declaration and new value(`Singapore`) after the declaration. Hence, the value `undefined` print first followed by new value `Singapore` in the execution phase."
    },
    {
      "text": "#Answer: 1",
      "options": [
        {
          "text": "By default, plain objects are not iterable",
          "is_correct": false
        },
        {
          "text": "Each context(global or functional) has it's own variable environment and the callstack of variables in a LIFO order",
          "is_correct": true
        },
        {
          "text": "The javascript parser will automatically add a semicolon while parsing the source code",
          "is_correct": false
        },
        {
          "text": "Yes, you can apply chaining on conditional operators similar to **`if … else if … else if … else`** chain",
          "is_correct": false
        }
      ],
      "explanation": "Each context(global or functional) has it's own variable environment and the callstack of variables in a LIFO order. So you can see the message variable value from second, first functions in an order followed by global context message variable value at the end."
    },
    {
      "text": "#Answer: 1",
      "options": [
        {
          "text": "In JavaScript, primitive types include boolean, string, number, BigInt, null, Symbol and undefined",
          "is_correct": false
        },
        {
          "text": "The function call `functionOne` is not going to be part of scope chain and it has it's own execution context with the enclosed variable environment",
          "is_correct": true
        },
        {
          "text": "Nowadays JavaScript language is used in a wide variety of environments and each environment has its own object model",
          "is_correct": false
        },
        {
          "text": "Currying** is the process of transforming a function with **multiple arguments** into a sequence of **nested functions**, each accepting **only one argument** at a time",
          "is_correct": false
        }
      ],
      "explanation": "The function call `functionOne` is not going to be part of scope chain and it has it's own execution context with the enclosed variable environment. i.e, It won't be accessed from global context. Hence, there will be an error while invoking the function as `functionOne is not defined`."
    },
    {
      "text": "#Answer: 4",
      "options": [
        {
          "text": "`Symbol` is a just a standard function and not an object constructor(unlike other primitives new Boolean, new String and new Number)",
          "is_correct": false
        },
        {
          "text": "`this` keyword is dynamic scoped but not lexically scoped",
          "is_correct": true
        },
        {
          "text": "Object literals make it easy to quickly create objects with properties inside the curly braces",
          "is_correct": false
        },
        {
          "text": "This is a semicolon issue",
          "is_correct": false
        }
      ],
      "explanation": "`this` keyword is dynamic scoped but not lexically scoped . In other words, it doesn't matter where `this` has been written but how it has been invoked really matter. In the above code snippet, the `user` object invokes `eat` function so `this` keyword refers to `user` object but `eatFruit` has been invoked by `eat` function and `this` will have default `Window` object.\n\nThe above pit fall fixed by three ways,\n\n1. In ES6, the arrow function will make `this` keyword as lexically scoped. Since the surrounding object of `this` object is `user` object, the `eatFruit` function will contain `user` object for `this` object.\n\n```javascript\nconst user = {\n  name: \"John\",\n  eat() {\n    console.log(this);\n    var eatFruit = () => {\n      console.log(this);\n    };\n    eatFruit();\n  },\n};\nuser.eat();\n```\n\nThe next two solutions have been used before ES6 introduced.\n\n2.  It is possible create a reference of `this` into a separate variable and use that new variable inplace of `this` keyword inside `eatFruit` function. This is a common practice in jQuery and AngularJS before ES6 introduced.\n\n```javascript\nconst user = {\n  name: \"John\",\n  eat() {\n    console.log(this);\n    var self = this;\n    var eatFruit = () => {\n      console.log(self);\n    };\n    eatFruit();\n  },\n};\nuser.eat();\n```\n\n3. The `eatFruit` function can bind explicitly with `this` keyword where it refers `Window` object.\n\n```javascript\nconst user = {\n  name: \"John\",\n  eat() {\n    console.log(this);\n    var eatFruit = function () {\n      console.log(this);\n    };\n    return eatFruit.bind(this);\n  },\n};\nuser.eat()();\n```"
    },
    {
      "text": "#Answer: 1",
      "options": [
        {
          "text": "The javascript parser will automatically add a semicolon while parsing the source code",
          "is_correct": false
        },
        {
          "text": "JavaScript does not have built-in support for mixins as a formal language feature",
          "is_correct": false
        },
        {
          "text": "Eventhough both variables `a` and `b` refer a number value, the first declaration is based on constructor function and the type of the variable is going to be `object` type",
          "is_correct": true
        },
        {
          "text": "Browsers provide an XMLHttpRequest object which can be used to make synchronous HTTP requests from JavaScript",
          "is_correct": false
        }
      ],
      "explanation": "Eventhough both variables `a` and `b` refer a number value, the first declaration is based on constructor function and the type of the variable is going to be `object` type. Whereas the second declaration is primitive assignment with a number and the type is `number` type. Hence, the equality operator `===` will output `false` value."
    },
    {
      "text": "#Answer: 2",
      "options": [
        {
          "text": "JavaScript provided a trim method on string types to trim any whitespaces present at the beginning or ending of the string",
          "is_correct": false
        },
        {
          "text": "Eventhough the above function returns the same result for the same arguments(input) that are passed in the function, the `console",
          "is_correct": true
        },
        {
          "text": "You can use the navigator object to detect a browser language preference as below,\n\n      **⬆ **\n\n183",
          "is_correct": false
        },
        {
          "text": "You can use the `getTimezoneOffset` method of the date object",
          "is_correct": false
        }
      ],
      "explanation": "Eventhough the above function returns the same result for the same arguments(input) that are passed in the function, the `console.log()` statement causes a function to have side effects because it affects the state of an external code. i.e, the `console` object's state and depends on it to perform the job. Hence, the above function considered as impure function."
    },
    {
      "text": "#Answer: 4",
      "options": [
        {
          "text": "If an object is frozen using the `Object",
          "is_correct": false
        },
        {
          "text": "The javascript parser will automatically add a semicolon while parsing the source code",
          "is_correct": false
        },
        {
          "text": "A _repaint_ occurs when changes are made which affect the visibility of an element, but not its layout",
          "is_correct": false
        },
        {
          "text": "The function `printHello` is hoisted to the top of the global scope and prints \"Hello\" to the console",
          "is_correct": true
        }
      ],
      "explanation": "The function `printHello` is hoisted to the top of the global scope and prints \"Hello\" to the console. Even `printMessage` function is hoisted, but it is lifted to the local scope(in \"printHello\") it was declared in. That is the reason you will endup with reference error for second function call.\n\nBut if the second function is invoked in the first function itself, there won't be any reference error.\n\n```javascript\nprintHello();\n\nfunction printHello() {\n  printMessage();\n  console.log(\"Hello\");\n\n  function printMessage() {\n    console.log(\"Good day\");\n  }\n}\n```"
    },
    {
      "text": "#Answer: 1",
      "options": [
        {
          "text": "If a function is called with `undefined`, the `undefined` value is treated as a parameter",
          "is_correct": true
        },
        {
          "text": "If you want to access any element in an HTML page, you need to start with accessing the document object",
          "is_correct": false
        },
        {
          "text": "You need to use date",
          "is_correct": false
        },
        {
          "text": "history object contains the browser's history",
          "is_correct": false
        }
      ],
      "explanation": "If a function is called with `undefined`, the `undefined` value is treated as a parameter. But if the function is not passed with any parameters, the `arguments` object doesn't include any argument eventhough the function has default function parameter. Hence, the function invocation with `undefined` has one argument and function call without any arguments has 0 arguments."
    },
    {
      "text": "#Answer: 1",
      "options": [
        {
          "text": "If a function is called with `undefined`, the `undefined` value is treated as a parameter",
          "is_correct": true
        },
        {
          "text": "The `extends` keyword is used in class declarations/expressions to create a class which is a child of another class",
          "is_correct": false
        },
        {
          "text": "Arrow functions do not have an `arguments, super, this, or new",
          "is_correct": false
        },
        {
          "text": "Code snippet:**\n\n      **Output:**\n\n      The output is 40 and NaN",
          "is_correct": false
        }
      ],
      "explanation": "If a function is called with `undefined`, the `undefined` value is treated as a parameter. But if the function is not passed with any parameters, the `arguments` object doesn't include any argument eventhough the function has default function parameter. Hence, the function invocation with `undefined` has one argument and function call without any arguments has 0 arguments."
    }
  ]
}